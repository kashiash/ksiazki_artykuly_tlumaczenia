# Swifti SwiftUI

## Closures



Translation
Co to za nawiasy? O co chodzi z tymi znakami dolara? Ucieczka? Przed kim uciekamy? Końcowa składnia zamykająca? Co to w ogóle znaczy? `closures` są trudne. Są to rzeczy, które wprawiają mnie w zakłopotanie znacznie głębiej w mojej karierze, niż chciałbym przyznać. Upewnijmy się, że zrozumiesz `closures` znacznie szybciej niż ja. 

 **`Closures` to samodzielne bloki funkcjonalności, które mogą być przekazywane i używane w kodzie.** Mówiąc prościej, są to funkcje, które można przekazywać dalej. 

Aby to zilustrować, stwórzmy `Closure` i wykorzystajmy je w praktyce. Oto jestem w  `Xcode Playground`. Wszystko, co mam, to strukturę Student, który ma imię i nazwisko oraz wynik testu, a następnie mam tablicę wyników uczniów uczniów. 

```swift
struct Student {
    let name: String
    var testScore: Int
}

let students = [
    Student(name: "John Smith", testScore: 90),
    Student(name: "Emma Johnson", testScore: 85),
    Student(name: "Michael Davis", testScore: 92),
    Student(name: "Sophia Williams", testScore: 88),
    Student(name: "Daniel Jones", testScore: 95),
    Student(name: "Olivia Taylor", testScore: 78),
    Student(name: "William Brown", testScore: 87),
    Student(name: "Ava Miller", testScore: 94),
    Student(name: "James Wilson", testScore: 89),
    Student(name: "Emily Anderson", testScore: 91)
]
```

Utworzymy `Closure`, aby odfiltrować uczniów według ich wyniku testu. 

```swift
var topStudentsFilter: () -> () = { 
  //closure code 
}
```

Kluczowym słowem jest tutaj typ, ponieważ tak jak nasz uczeń ma `name` typu String, a `testScore` jest typu Int, tak nasze domknięcie jest zmienną typu i tutaj pojawiają się nawiasy. 

Zasadniczo jest to sygnatura funkcji. Wpiszę to, a my przejdziemy przez to i wyjaśnimy. Otrzymujesz jeden zestaw nawiasów, a następnie typ zwracany jest drugim zestawem nawiasów, który jest równy, a następnie rzeczywiste nawiasy klamrowe definiujące zakres. Przejdźmy przez te nawiasy jeden po drugim, ponieważ wiem, że bardzo mnie to zmyliło, kiedy po raz pierwszy uczyłem się zamknięć. 

Pierwszy zestaw nawiasów to wszelkie parametry przyjmowane przez funkcję. Nie musimy ich jednak nazywać. Potrzebujemy tylko ich typu. Chcemy przyjąć typ Student. 

```swift
var topStudentsFilter: (Student) -> () = { 
  //closure code 
}
```

Oczywiście, jeśli robisz coś z int lub string, to właśnie tam byś to przekazał.  A to zwróci wartość logiczną. Cofnę się i wyjaśnię to naprawdę szybko, ponieważ być może widziałeś, że czasami nic nie zwraca, więc możesz zobaczyć puste nawiasy, a czasami, jeśli nic nie zwraca, możesz również zobaczyć void. Te puste nawiasy i void to to samo, tylko na dwa różne sposoby. 

W naszym przypadku przekażemy wartość logiczną, ponieważ jest to filtr, gdzie przyjrzymy się naszemu uczniowi i jeśli nasz uczeń ma wynik większy niż 80, zwrócimy wartość true. Oznacza to, że jest naszym najlepszym uczniem. 

Dlatego właśnie przekazaliśmy studenta i zwróciliśmy wartość logiczną. Chcemy tylko sprawdzić, czy ma wynik większy niż 80. Zwracamy więc studenta, ale nie możemy jeszcze tego zrobić w ten spsób: 

```swift
var topStudentsFilter: (Student) -> Bool = { 
  return student 
}
```

Brakuje nam tutaj elementu, w którym musimy nazwać nasz parametr, student in. Widziałeś to już wcześniej. Jest to w zasadzie nazwa parametru. Możemy jej użyć tutaj, w zakresie naszego `closures`. Mogę więc zrobić return student. test score. Nie wiem dlaczego autouzupełnianie nie współpracuje, ale większy niż 80. 

```swift
var topStudentsFilter: (Student) -> Bool = { student in
    return student.testScore > 80
}
```

 Napiszmy to jako funkcję, abyś mógł porównać te dwie, ponieważ zakładam, że jesteś trochę zaznajomiony z funkcjami. Więc po prostu skopiowałem i wkleiłem to. Aby napisać funkcję, to func, top student filter. Zamierzam umieścić po nim Func dla odróznienia funkcji. 

```swift
func topStudentsFilterFunc( student: Student) -> Bool  {
    return student.testScore > 80
}
```

 Ale chcę tylko umieścić je obok siebie, abyś mógł zobaczyć, jak bardzo są podobne. Jak powiedziałem, jest to właściwość z nazwą typu, tak jak string i int. Typem jest tutaj sygnatura funkcji. Przyjmuje ona typ student i zwraca bool. To właśnie się tutaj dzieje. Typ student zwraca wartość bool. A tutaj, student jest tym, co nazwaliśmy. Możemy nazwać go jakkolwiek chcemy, tak jak możemy nazwać ten parametr jakkolwiek chcemy. Oczywiście zakres jest w zasadzie taki sam. Mam nadzieję, że to wyjaśnia, czym są te nawiasy, gdy widzisz je w `closures`ch. Ponownie, to po prostu dowolne parametry i to, co zwraca, tak jak funkcja, parametry i to, co zwraca. 

 Ale tak czy inaczej, teraz, gdy mamy nasze `Closure`, przekażemy je za pomocą naszej zmiennej. Więc zróbmy to. Powiedzmy, że niech top students będzie równe students. Nawiasem mówiąc, studenci to nasza tablica tutaj. To jest nasza tablica wszystkich naszych studentów. Filtr. Jak widać, nasz filtr przyjmuje `Closure`. I tak jak powiedzieliśmy, tutaj jest typ. Przyjmuje studenta i zwraca bool. Tak więc jedynym sposobem, w jaki będziemy mogli przekazać nasze `Closure`, jest idealne dopasowanie. Przyjmuje ucznia i zwraca wartość logiczną. Powiedzmy, że nasze `Closure` miało tutaj ucznia i int. Nawiasem mówiąc, w ten sposób można mieć wiele typów, na przykład student-age. Gdybyś miał wiele typów w swoim zamknięciu, zgaduję, że byłoby to wiele parametrów. Teraz nasze `Closure` nie zadziała, ponieważ nie pasuje dokładnie. Więc usunę to, ponieważ chcę, aby działało. Teraz mogę po prostu przekazać filtr top student. A teraz wkleję krótką pętlę for, aby zaoszczędzić trochę czasu. 

Zasadniczo po prostu wypisuje imię i nazwisko ucznia. Uruchomimy ją i filtr powinien zadziałać. Tak, mamy Luke'a, Leię i Ahsokę. Te wyniki muszą być większe niż 80. Luke ma 88, Leia 95, a Ahsoka 86. Tak więc nasz filtr działa, przekazując tam nasze `Closure`. Ponownie, `Closure` jest funkcją, która może być przekazywana. I jest to o wiele schludniejsze niż gdybyśmy to napisali. 



Więc zademonstrujmy to. Cóż, naprawdę szybko, pozwól mi zademonstrować, jak możemy również przekazać tę funkcję. Więc pozwól mi zrobić top student filter z wielką literą F na końcu. To jest właśnie to. A teraz, kiedy go uruchomię, pamiętaj, że jesteśmy więksi niż 70. Właśnie dlatego to zrobiłem, abyśmy mogli różnicować. Więc teraz, kiedy to uruchomię, powinienem uzyskać dłuższą listę uczniów, co robię, ponieważ więcej uczniów tutaj ma więcej niż 70 lat. Ponownie, niezależnie od tego, czy jest to właściwość, czy funkcja, bardzo podobna. `Closure` jest funkcją, która może być przekazywana i używana. Teraz, gdy już to zobaczyłeś, zacznijmy mówić o skrócie i co oznaczają te wszystkie znaki dolara. Zamierzam więc przepisać ten filtr tutaj lub ponownie go uzupełnić. Filtr jest więc włączony. Jak widać, da mi to `Closure`, które przyjmuje studenta i zwraca wartość logiczną. Jeśli nacisnę return, otrzymam trochę skrótu i automatycznie przejdę do składni końcowego `closures`, o której więcej powiemy za chwilę. Ale wprowadzenie, jeśli wykonam polecenie Z, składnia `closures` końcowego jest wtedy, gdy można pominąć etykietę argumentu, gdy `Closure` jest ostatnim argumentem. Będziemy dużo o tym mówić w SwiftUI, ponieważ SwiftUI używa tego w dużym stopniu nieco więcej w filmie, ale nasze `Closure` jest naszym jedynym parametrem. Więc oczywiście jest to nasz ostatni parametr. Kiedy więc nacisnę return, otrzymamy końcową składnię domknięcia, która pomija nazwy parametrów w nawiasach i po prostu przechodzi do treści domknięcia w ten sposób. Teraz mamy nazwę naszego argumentu i nie musimy definiować jego typu. Powodem, dla którego nie musimy definiować typu, jest fakt, że filtr działa na tablicy studentów, prawda? Nasza tablica studentów ma tutaj wnioskowanie o typie. Wie, że jest to tablica studentów. Nie jest to tablica ciągów znaków, ani tablica liczb podwójnych, ani nic podobnego. To studenci. Dlatego nie musimy definiować typu. Możemy po prostu nazwać to, jak chcemy. Duża litera S w nazwie student oznacza, że jest to typ student. Nazwiemy go małymi literami student, tak jak nazwę. Ponownie, mogliśmy nazwać tę osobę, prawda? Możesz nazwać ją jak chcesz. Student oczywiście ma największy sens, ale wiemy, że jest to typ student. Więc tutaj możemy napisać ten sam kod. Używam prostej jednej linii kodu, ale oczywiście mogłoby to być 40 linii. Mógłby to być bardzo złożony kod filtrujący. Dlatego nie warto pisać wszystkiego od razu. Możesz chcieć umieścić go we właściwości, aby można go było ponownie wykorzystać, bardzo łatwo przekazać, w przeciwieństwie do tego, jak teraz piszę go na miejscu w zakresie filtra. Ponownie, wygląda to teraz dobrze, ponieważ jest to tylko jedna linia kodu, ale chcę użyć tego prostego przykładu, aby pokazać ci skrót. Parametry te mają wbudowaną skróconą składnię. Prawdopodobnie widziałeś znak dolara zero lub znak dolara jeden. To reprezentuje każdy parametr tutaj. W tej chwili mamy tylko jeden, więc jest to znak dolara zero. Za chwilę pokażę ci przykład, w którym mamy znak dolara zero i znak dolara jeden. Więc jak mogę powoli zrobić ten skrót, to jeśli nie chcę używać rzeczywistej nazwanej właściwości tutaj, pozbądź się tego i pozbądź się końca. A teraz zamiast studenta tutaj, mogę zastąpić go znakiem dolara zero, ponieważ mam tylko jeden argument. Nie ma znaku dolara jeden. Jest tylko znak dolara zero. Wiem więc, że to student. Teraz, gdy mamy tylko jedną linię kodu, możemy pominąć return. A jeśli zamierzamy pominąć powrót, możemy umieścić to wszystko w jednej linii, aby było ładne, schludne i czyste. Jest to więc wprowadzenie do skrótu i tego, czym jest znak dolara zero i znak dolara jeden. W tej chwili mamy tylko najlepszych studentów. Odfiltrowaliśmy wszystkich najlepszych uczniów na podstawie tego, czy ich wynik testu jest wyższy niż 80. Teraz posortujmy to, aby zobaczyć przykład znaku dolara zero i znaku dolara jeden i po prostu więcej powtórzeń na `closures`ch, ponieważ ponownie, `closures` są trudne. Powiedzmy więc, że ranking studentów jest równy najlepszym studentom. Więc chcemy wziąć tylko najlepszych studentów, którzy zostali posortowani według. I tutaj znowu widać, że jest to przykład, gdy mamy dwa z tych parametrów. Mamy studenta pierwszego i studenta drugiego, a funkcja zwraca wartość logiczną. Więc gdybyśmy mieli napisać `Closure` dla tego, musielibyśmy upewnić się, że mamy w nim dwóch uczniów, prawda? Więc musielibyśmy być studentem, studentem. A potem oczywiście napisalibyśmy inną logikę, aby wykonać tutaj całe sortowanie. Ale tak jak powiedziałem, chcę tylko zwrócić uwagę, że tutaj również musielibyśmy mieć ucznia drugiego, ale chciałem zwrócić uwagę, że jeśli zamierzasz użyć `closures` we wbudowanym, takim jak sortowane lub filtr, musi ono dokładnie pasować lub jeśli sam napisałeś funkcję, musi ona dokładnie pasować. Wykonam więc polecenie Z, aby przywrócić nasze `Closure` do tego. Następnie wcisnę return i ponownie przejdę przez ten skrót. Tak jak powiedziałem, możesz mieć ucznia pierwszego, ucznia drugiego, a następnie zwrócić wynik testu kropki ucznia pierwszego większy niż wynik testu kropki ucznia drugiego. Spowoduje to posortowanie ich na podstawie tego, czyj wynik testu jest wyższy. Ale znowu, wracając do skrótu, nie potrzebujemy studenta jeden, studenta dwa, wiem, że jest to znak dolara zero i znak dolara jeden. Więc możemy się tego pozbyć, aby było czyściej. Następnie zastąpię studenta pierwszego znakiem dolara zero, a studenta drugiego znakiem dolara jeden. Teraz, jeśli dodasz trzy lub cztery parametry, będzie to znak dolara dwa, znak dolara trzy i tak dalej. Jak powiedziałem wcześniej, nie potrzebujemy powrotu. Możemy więc umieścić to w jednej linii. I gotowe. Tak jak powiedziałem, jeśli widziałeś wiele tych zamknięć ze znakami dolara i znakiem dolara jeden znak dolara dwa, są to zasadniczo skrócone składnie dla każdej właściwości, tak jak właśnie pokazaliśmy ze studentem i studentem jeden i studentem dwa. Mam nadzieję, że to wyjaśniło ci całą składnię znaków dolara. Wiem, że było to mylące również dla mnie, kiedy zaczynałem. Porozmawiajmy jeszcze o składni zamykania, zanim przejdziemy do ucieczki. Przejdźmy do projektu SwiftUI, aby zobaczyć, jak wygląda to wszędzie w SwiftUI. Tutaj jestem w moim kursie o nazwie dub dub grub. Nawiasem mówiąc, możesz to sprawdzić Seanisland. teachable. com, jeśli jesteś zainteresowany. Jeśli kiedykolwiek pisałeś VStack lub HStack w SwiftUI, używałeś składni `closures` końcowego. A jeśli napisałeś dużo SwiftUI, zrobiłeś to wiele, wiele razy. Pozwól więc, że to wyjaśnię. Oto jestem w podstawowym małym przycisku. Powiedzmy, że chcę umieścić ten tekst w VStack. Więc robię ten VStack. Super. Teraz, kiedy napisałeś VStack, po prostu otworzyłeś nawias klamrowy, zamknąłeś nawias klamrowy. I prawdopodobnie nic o tym nie myślałeś, jeśli nie rozumiesz końcowych domknięć. Ale tak właśnie jest. Jest to `Closure` końcowe. Porozmawiajmy więc o tym, czym naprawdę jest VStack. Więc jeśli zrobię VStack, przytrzymaj opcję, aby uzyskać wszystkie parametry, prawda? Są one po prostu opcjonalne. SwiftUI jest pełne opcjonalnych parametrów i wartości domyślnych. Pokażę ci to za chwilę. Ale to, na co chcę zwrócić uwagę, to fajny parametr. Możesz zrobić kropkę wiodącą, odstępy, powiemy 10. Ale spójrz, czym to się kończy? Kończy się treścią. A jak wygląda ta składnia? To wygląda jak `Closure`. `Closure` jest ostatnim argumentem. Możemy więc go pominąć i po prostu wykonać końcową składnię `closures`, która po prostu przechodzi bezpośrednio do treści `closures`, nawiasów klamrowych. I naprawdę szybko, aby ci pokazać, jeśli kliknę polecenie na VStack, przeskoczę do definicji, przejdę do init tutaj, możesz zobaczyć, że wyrównanie ma domyślną wartość dot center, odstępy, domyślna wartość nil. Jak już wspomniałem, wartości domyślne są wszędzie w SwiftUI. To właśnie pozwala na czystą składnię. No i proszę. Czy to wygląda znajomo? Cóż, ViewBuilder to inny temat. Ale widać, że ostatnim argumentem jest zawartość. To `Closure` wygląda znajomo, prawda? Nie przyjmuje żadnych parametrów i zwraca zawartość typu. Wracamy więc szybko do VStack. Dlatego możemy się tego pozbyć. I właśnie dlatego możesz napisać VStack, który jest prostym VStack, otwartym nawiasem klamrowym, zamkniętym nawiasem klamrowym, końcową składnią `closures` w całym SwiftUI. Zanim porozmawiamy o ucieczce od domknięć, muszę opowiedzieć o dzisiejszym sponsorze, Squarespace. Squarespace to kompleksowa platforma, która pomaga w szybkim uruchomieniu portfolio programisty iOS, bloga lub osobistej strony internetowej. Teraz wiem, że wszyscy jesteśmy programistami z tymi umiejętnościami i chęcią samodzielnego zbudowania strony internetowej. Twierdzę jednak, że poświęcony czas wiąże się z pewnym kosztem alternatywnym. Jeśli jesteś programistą iOS próbującym zbudować świetny produkt, świetną aplikację, być może spędzasz dużo czasu na poznawaniu tajników tworzenia stron internetowych, responsywny design nie jest najlepszym sposobem na spędzenie czasu. Dlatego też polecam Squarespace do zbudowania osobistej strony internetowej, bloga, portfolio lub strony docelowej aplikacji. Mają wiele pięknych motywów i szablonów, które pomogą ci zacząć. Zajmują się całą analityką i SEO. Ponownie, oszczędza to wiele czasu, dzięki czemu możesz wrócić do robienia tego, co chcesz robić, czyli tworzenia aplikacji na iOS. Więc kiedy będziesz gotowy, aby rozpocząć, przejdź do squarespace. com, aby rozpocząć bezpłatny okres próbny. A kiedy będziesz gotowy do uruchomienia, przejdź do squarespace. com/seanallen, aby uzyskać 10% zniżki na pierwszy zakup strony internetowej lub domeny. Jeśli kiedykolwiek napisałeś wywołanie sieciowe przed Async/Await, miałeś do czynienia z programami obsługi zakończenia lub `closures`mi. Są one tym samym. Przyjrzyjmy się sygnaturze funkcji get followers. Nawiasem mówiąc, to idzie do GitHub API, ściąga listę obserwujących do wyświetlenia na ekranie. Ok, więc parametry, nazwa użytkownika, strona, zakończone. To jest `Closure` tutaj i jest oznaczone ucieczką. Porozmawiamy o tym, co to oznacza. Ale aby przejrzeć `Closure`, nasze `Closure` przyjmuje typ wyniku, a typ wyniku zwraca obserwatora lub błąd GIF, a następnie zwraca void. Więc nic nie zwraca. Ponownie, tak jak powiedziałem, może to być po prostu `Closure` nawiasów, dokładnie to samo. Ale dlaczego jest oznaczony jako uciekający? Cóż, `closures`, które robiliśmy wcześniej, na przykład podczas filtrowania uczniów, zdarzają się natychmiast. Są wywoływane od razu. Dzieje się to od razu, nic wielkiego. W przypadku wywołań sieciowych uruchamia się to i przechodzi do chmury, do interfejsu API GitHub, i w zależności od sieci, może to być bardzo powolne, może zająć 10 sekund, może zająć milisekundę. Może nawet nie masz połączenia z Internetem, może to potrwać wieczność. Więc to, co robi escaping, to pozwala zamknięciu żyć po upływie czasu życia funkcji, która je wywołała. Mówiąc o funkcji, która ją wywołała, spójrzmy na to. Tak więc na liście obserwujących VC, która jest tym ekranem, możesz zobaczyć tutaj w funkcji get followers, wywołuję networkmanager. share. getFollowers. I znowu, jak widać tutaj, używamy składni końcowego `closures`, ponieważ jest to ostatni argument w funkcji. Ale co się dzieje, getFollowers uruchamia się, a następnie ta funkcja jest wykonywana. `Closure` jest jednak nadal aktywne. Przeżywa funkcję, ponieważ czeka na uzyskanie informacji z wywołania sieciowego. Dlatego właśnie zaznaczasz go podczas ucieczki, aby mógł żyć po tym. W tym miejscu sprawy stają się nieco skomplikowane z zachowanymi cyklami i wyciekami pamięci, ponieważ przez większość czasu, gdy wykonujesz połączenie sieciowe, przechwytujesz odniesienie do siebie, ponieważ po odzyskaniu listy obserwujących, niezależnie od tego, czy jest to 10 sekund później, 15 sekund później, sekundę później, musisz zaktualizować interfejs użytkownika w telefonie. Więc nasze `Closure` nadal musi mieć odniesienie do tego, co je wywołało. W tym przypadku jest to kontroler widoku w UIKit. Dlatego właśnie należy uważać z uciekaniem z zamknięć. Zaznaczyliśmy tutaj słabe self. Jest to więc cotygodniowa referencja, więc może się zepsuć. Wiąże się to z zarządzaniem pamięcią, automatycznym zliczaniem referencji i innymi rzeczami. To zupełnie inny temat. Mam film na ten temat. Jeśli chcesz, podam link do niego w opisie. Ale to właśnie oznacza ucieczka. Zasadniczo `Closure` musi żyć po zakończeniu życia funkcji, która pierwotnie je wywołała. Jeśli to było pomocne i podobał Ci się mój styl nauczania, sprawdź moje kursy na SeanAlan. Teachable. com.