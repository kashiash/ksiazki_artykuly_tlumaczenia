

# Architektura obserwowalna: Sneak Peek

Odcinek #259 - 27 listopada 2023 r. - odcinek bezpÅ‚atny

https://www.pointfree.co/episodes/ep259-observable-architecture-sneak-peek

Zamierzamy caÅ‚kowicie zrewolucjonizowaÄ‡ architekturÄ™ kompozytowÄ… dziÄ™ki nowemu frameworkowi Observation w Swift! Ale najpierw zajawka: zabierzemy publicznÄ… wersjÄ™ beta (dostÄ™pnÄ… juÅ¼ dziÅ›!) na przejaÅ¼dÅ¼kÄ™, aby zobaczyÄ‡, jak koncepcja "magazynu widokÃ³w" caÅ‚kowicie znika podczas korzystania z nowych narzÄ™dzi.

Aha, i czy wspomnieliÅ›my, Å¼e nowe narzÄ™dzia do obserwacji w bibliotece zostaÅ‚y przeniesione z powrotem do iOS 13? Oznacza to, Å¼e moÅ¼na z nich korzystaÄ‡ natychmiast. ğŸ¤¯



# Wprowadzenie
00:05
Stephen: Dzisiaj rozpoczynamy seriÄ™ odcinkÃ³w, ktÃ³re caÅ‚kowicie zrewolucjonizujÄ… naszÄ… popularnÄ… bibliotekÄ™, Composable Architecture. MÃ³wiliÅ›my juÅ¼ o tym wczeÅ›niej.

00:12
Po raz pierwszy powiedzieliÅ›my to, gdy wprowadziliÅ›my do biblioteki async/await. ZrewolucjonizowaÅ‚o to sposÃ³b traktowania efektÃ³w w bibliotece.
00:19
Brandon:

Potem powiedzieliÅ›my to ponownie, gdy wprowadziliÅ›my protokÃ³Å‚ Reducer. To zrewolucjonizowaÅ‚o sposÃ³b komponowania funkcji i wykorzystywania zaleÅ¼noÅ›ci.
00:27
Stephen:

A potem powiedzieliÅ›my to ponownie, gdy wprowadziliÅ›my do biblioteki narzÄ™dzia nawigacyjne. To zrewolucjonizowaÅ‚o sposÃ³b zwiÄ™zÅ‚ego modelowania domen funkcji.
00:35
CÃ³Å¼, za kaÅ¼dym razem mÃ³wiliÅ›my prawdÄ™, ale tym razem jest inaczej. To jeszcze wiÄ™ksza rewolucja.

00:41
Brandon: Kilka tygodni temu zakoÅ„czyliÅ›my seriÄ™ odcinkÃ³w, w ktÃ³rych zagÅ‚Ä™bialiÅ›my siÄ™ w nowy framework Observation wydany wraz ze Swift 5.9. Framework ten jest czÄ™Å›ciÄ… projektu Swift o otwartym kodzie ÅºrÃ³dÅ‚owym i ma byÄ‡ bardzo ogÃ³lnym narzÄ™dziem do obserwowania, jak dane wewnÄ…trz klasy zmieniajÄ… siÄ™ w czasie.

00:58
Jest tak potÄ™Å¼ny, Å¼e caÅ‚kowicie zmienia sposÃ³b tworzenia funkcji w SwiftUI. Przed pojawieniem siÄ™ frameworka Observation trzeba byÅ‚o dobrze znaÄ‡ caÅ‚e zoo wrapperÃ³w wÅ‚aÅ›ciwoÅ›ci i typÃ³w, aby skrupulatnie opisaÄ‡ stan funkcji, aby wyraÅºnie powiedzieÄ‡ SwiftUI, jaki stan powinien byÄ‡ obserwowany, i trzeba byÅ‚o tylko mieÄ‡ nadziejÄ™, Å¼e zrobisz to dobrze.

01:18
Stephen:: Ale teraz dziÄ™ki frameworkowi Observation moÅ¼esz zapomnieÄ‡ o prawie caÅ‚ej tej zÅ‚oÅ¼onoÅ›ci i po prostu budowaÄ‡ swoje funkcje w najbardziej naiwny sposÃ³b, z praktycznie zerowymi ozdobnikami i to po prostu dziaÅ‚a. I dziaÅ‚a w najbardziej wydajny moÅ¼liwy sposÃ³b, w ktÃ³rym tylko dane dostÄ™pne w widoku sÄ… obserwowane przez widok.

01:34
ByÅ‚o to doÅ›Ä‡ rewolucyjne dla SwiftUI, ale uwaÅ¼amy, Å¼e moÅ¼e byÄ‡ rÃ³wnie rewolucyjne dla architektury komponowalnej. Framework Observation pozwala nam pozbyÄ‡ siÄ™ wielu koncepcji, ktÃ³re byÅ‚y potrzebne przed frameworkiem, przede wszystkim koncepcji ViewStore, ale takÅ¼e takich rzeczy jak IfLetStore, ForEachStore, SwitchStore i caÅ‚ej gamy modyfikatorÃ³w widoku do wyÅ›wietlania arkuszy, peÅ‚noekranowych okÅ‚adek, wyskakujÄ…cych okienek i innych.

01:58
Brandon: Co wiÄ™cej, byliÅ›my w stanie naÅ‚oÅ¼yÄ‡ te narzÄ™dzia bez naruszania Å¼adnego ze starych narzÄ™dzi. Oznacza to, Å¼e kiedy w koÅ„cu udostÄ™pnimy tÄ™ aktualizacjÄ™ biblioteki, bÄ™dzie to niewielkie wydanie biblioteki. A jeÅ›li jesteÅ› w stanie korzystaÄ‡ z narzÄ™dzi obserwacyjnych Swift 5.9, bÄ™dziesz mÃ³gÅ‚ rÃ³wnieÅ¼ natychmiast skorzystaÄ‡ z narzÄ™dzi obserwacyjnych Composable Architecture.

02:18
Stephen: Ale potem poszliÅ›my dalej. PrzeportowaliÅ›my wszystkie narzÄ™dzia obserwacyjne z projektu open source Swift bezpoÅ›rednio do Composable Architecture. Oznacza to, Å¼e moÅ¼esz zaczÄ…Ä‡ korzystaÄ‡ z narzÄ™dzi obserwacyjnych juÅ¼ dziÅ›. JuÅ¼ teraz. Nawet jeÅ›li nadal wspierasz iOS 13! Nie Å¼artujemy. BÄ™dziesz mÃ³gÅ‚ natychmiast wykorzystaÄ‡ wszystko, co omÃ³wimy w tej serii.

02:38
Brandon: To wszystko brzmi moÅ¼e zbyt dobrze, by mogÅ‚o byÄ‡ prawdziwe, ale obiecujemy, Å¼e to prawda.

02:42
Wraz z poczÄ…tkiem tej serii wypuszczamy rÃ³wnieÅ¼ wersjÄ™ beta tych nowych narzÄ™dzi do obserwacji. Istnieje gaÅ‚Ä…Åº, do ktÃ³rej moÅ¼esz dziÅ› skierowaÄ‡ swoje projekty, aby upewniÄ‡ siÄ™, Å¼e Twoja aplikacja nadal siÄ™ kompiluje, testy przechodzÄ… pomyÅ›lnie i wszystko dziaÅ‚a zgodnie z oczekiwaniami. A jeÅ›li masz na to apetyt, moÅ¼esz nawet sprÃ³bowaÄ‡ zaktualizowaÄ‡ niektÃ³re ze swoich funkcji, aby korzystaÄ‡ z nowych narzÄ™dzi do obserwacji i zobaczyÄ‡, jak siÄ™ sprawy majÄ…! NaleÅ¼y pamiÄ™taÄ‡, Å¼e nie zalecamy polegania na tej gaÅ‚Ä™zi przez dÅ‚uÅ¼szy czas, poniewaÅ¼ moÅ¼e w niej wystÄ™powaÄ‡ wiele zmian i sporadycznych uszkodzeÅ„, poniewaÅ¼ naprawiamy rzeczy w okresie beta.

03:14
Stephen: PrzejdÅºmy wiÄ™c do rzeczy.

03:17
WÅ‚aÅ›ciwie zaczniemy od szybkiego przeglÄ…du tego, jak wyglÄ…dajÄ… ostateczne narzÄ™dzia. To tylko po to, aby daÄ‡ wszystkim przedsmak ekscytujÄ…cych rzeczy, ktÃ³re nadejdÄ…. A potem zaczniemy budowaÄ‡ wszystkie nowe narzÄ™dzia obserwacyjne bezpoÅ›rednio w bibliotece i zobaczymy, jak raz po raz usuwamy koncepcje z biblioteki i upraszczamy funkcje zbudowane z biblioteki.

03:33
A wiÄ™c zaczynajmy.

# Obserwowalna architektura
03:37
Mam juÅ¼ otwarty nowy projekt i wszystko, co zamierzam zrobiÄ‡, to sprÃ³bowaÄ‡ zaimportowaÄ‡ Composable Architecture:

```swift
import ComposableArchitecture
```

03:41
Xcode zasugeruje dodanie tej zaleÅ¼noÅ›ci do naszego projektu, co zrobimy. Ale zamiast przypinaÄ‡ do najnowszej wersji, przypniemy do nowej gaÅ‚Ä™zi beta, ktÃ³rÄ… dziÅ› wydajemy. Nazywa siÄ™ ona observation-beta.

04:01
A potem, zanim bÄ™dziemy mogli budowaÄ‡, musimy daÄ‡ Xcode pozwolenie na uÅ¼ywanie makr z Composable Architecture:

> "ComposableArchitectureMacros" musi byÄ‡ wÅ‚Ä…czone, zanim bÄ™dzie moÅ¼na z niego korzystaÄ‡.
>
> WÅ‚Ä…czyÄ‡ to teraz?
>
> Makra zawierajÄ…ce zÅ‚oÅ›liwy kod mogÄ… uszkodziÄ‡ komputer Mac lub naruszyÄ‡ prywatnoÅ›Ä‡. Przed wÅ‚Ä…czeniem makr upewnij siÄ™, Å¼e ufasz ich ÅºrÃ³dÅ‚u.
>

04:15
Composable Architecture dostarcza teraz wÅ‚asne makra, aby pomÃ³c w obserwacji. Nie powinno to byÄ‡ zbyt zaskakujÄ…ce, poniewaÅ¼ jak omÃ³wiliÅ›my w naszych poprzednich odcinkach obejmujÄ…cych makro @Observable, makro to dziaÅ‚a tylko dla klas, a aplikacje zbudowane przy uÅ¼yciu naszej biblioteki wolÄ… modelowaÄ‡ swoje domeny za pomocÄ… struktur. Nie mieliÅ›my wiÄ™c innego wyboru, jak tylko dostarczyÄ‡ nowe makra, ktÃ³re umoÅ¼liwiajÄ… obserwacjÄ™ pracy ze strukturami.

04:36
Ale skoro biblioteka jest juÅ¼ zaimportowana, stwÃ³rzmy bardzo podstawowÄ… funkcjÄ™!

04:39
Zaczniemy od zdefiniowania nowego typu do przechowywania funkcji i opatrzymy go adnotacjÄ… makra @Reducer, ktÃ³re zostaÅ‚o wydane zaledwie dwa tygodnie temu:

```swift
@Reducer
struct CounterFeature {
}
```

04:51
JeÅ›li po raz pierwszy widzisz makro @Reducer, nie martw siÄ™. W tej chwili nie robi ono zbyt wiele. Po prostu dostosowuje CounterFeature do protokoÅ‚u Reducer, a takÅ¼e kilka podstawowych kontroli lintingu wewnÄ…trz typu reduktora. W przyszÅ‚oÅ›ci bÄ™dzie robiÄ‡ wiÄ™cej, ale na razie nie musimy siÄ™ o to martwiÄ‡.

05:04
Reduktory majÄ… kilka wymagaÅ„, z ktÃ³rych pierwszym jest stan, ktÃ³rego funkcja potrzebuje do wykonania swojej pracy. W tym przypadku potrzebujemy jedynie dostÄ™pu do liczby caÅ‚kowitej count:

```swift
struct State {
  var count = 0
}
```

05:16
Zwykle w tym momencie moÅ¼na z wyprzedzeniem uczyniÄ‡ tÄ™ strukturÄ™ rÃ³wnÄ…, poniewaÅ¼ jeÅ›li jesteÅ› zaznajomiony z architekturÄ… komponowalnÄ…, wiesz, Å¼e w widoku bÄ™dziesz musiaÅ‚ obserwowaÄ‡ ten stan, a aby zminimalizowaÄ‡ ponowne obliczenia widoku, musimy usunÄ…Ä‡ zmiany stanu.

05:30
CÃ³Å¼, jest to dokÅ‚adnie ten rodzaj rzeczy, ktÃ³ry powinien zostaÄ‡ znacznie ulepszony dziÄ™ki nowym narzÄ™dziom do obserwacji w Swift 5.9. PowinniÅ›my przestaÄ‡ myÅ›leÄ‡ w kategoriach pomijania obliczeÅ„ widoku w oparciu o dosÅ‚ownie zmieniajÄ…cy siÄ™ stan, a zamiast tego myÅ›leÄ‡ w kategoriach Å›ledzenia przez widok, do ktÃ³rych elementÃ³w stanu uzyskano dostÄ™p i ponownego obliczania tylko wtedy, gdy te wÅ‚aÅ›ciwoÅ›ci zostanÄ… zmutowane.

05:47
OznaczaÅ‚oby to, Å¼e nie musimy nawet tworzyÄ‡ tego Equatable w tej chwili i powinno sprawiÄ‡, Å¼e nasze widoki bÄ™dÄ… bardziej wydajne, poniewaÅ¼ nie bÄ™dÄ… musiaÅ‚y obliczaÄ‡ rÃ³wnoÅ›ci typÃ³w danych w kaÅ¼dym miejscu. Ale oczywiÅ›cie ostatecznie prawdopodobnie bÄ™dziesz chciaÅ‚, aby ta struktura byÅ‚a rÃ³wna dla testÃ³w, ale nie bÄ™dziemy siÄ™ tym teraz martwiÄ‡.

06:00
Kolejnym wymaganiem jest typ reprezentujÄ…cy wszystkie akcje, ktÃ³re uÅ¼ytkownik moÅ¼e wykonaÄ‡ w widoku. W tej chwili bÄ™dziemy tylko modelowaÄ‡ akcje dekrementacji i inkrementacji:

```swift
enum Action {
  case decrementButtonTapped
  case incrementButtonTapped
}
```

06:13
Ostatnim wymaganiem jest reduktor do implementacji logiki dla funkcji. Ta funkcja jest doÅ›Ä‡ prosta, wiÄ™c moÅ¼emy po prostu to zrobiÄ‡:

Ostatnim wymaganiem jest reduktor, ktÃ³ry implementuje logikÄ™ dla funkcji. Ta funkcja jest doÅ›Ä‡ prosta, wiÄ™c moÅ¼emy po prostu to zrobiÄ‡:

```swift
var body: some ReducerOf<Self> {
  Reduce { state, action in
    switch action {
    case .decrementButtonTapped:
      state.count -= 1
      return .none
    case .incrementButtonTapped:
      state.count += 1
      return .none
    }
  }
}
```

06:51
Ale w rzeczywistoÅ›ci funkcje sÄ… zwykle bardziej skomplikowane, obejmujÄ…c kompozycjÄ™ wielu funkcji i wykonywanie efektÃ³w. Ale nie bÄ™dziemy siÄ™ tym teraz martwiÄ‡.

07:00
Mamy teraz zaimplementowanÄ… bardzo podstawowÄ… funkcjÄ™ Composable Architecture i robimy to w moÅ¼liwie najmniejszej liczbie ruchomych czÄ™Å›ci. Mamy stan, akcje, a nastÄ™pnie reduktor do sklejenia tych dwÃ³ch elementÃ³w.

07:09
Idealnie byÅ‚oby, gdybyÅ›my mogli wziÄ…Ä‡ tÄ™ funkcjÄ™ i podÅ‚Ä…czyÄ‡ jÄ… do widoku w najbardziej naiwny moÅ¼liwy sposÃ³b. Po pierwsze, mam nadziejÄ™, Å¼e mÃ³gÅ‚bym trzymaÄ‡ siÄ™ sklepu bezpoÅ›rednio w widoku w ten sposÃ³b:

```swift
struct ContentView: View {
  let store: StoreOf<CounterFeature>
}
```

07:21
Store to Å›rodowisko uruchomieniowe, ktÃ³re zasila widok z funkcji architektury komponowalnej. Jest odpowiedzialny za przetwarzanie akcji wysyÅ‚anych z widoku, mutowanie stanu, powiadamianie widokÃ³w o zmianie stanu, wykonywanie efektÃ³w i przekazywanie wynikÃ³w efektÃ³w z powrotem do systemu.

07:36
JeÅ›li jesteÅ› zaznajomiony z Composable Architecture, to wiesz, Å¼e obok Store istnieje koncepcja rodzeÅ„stwa znana jako ViewStore. Historycznie byÅ‚o to konieczne, aby faktycznie obserwowaÄ‡ zmiany wewnÄ…trz sklepu i komunikowaÄ‡ SwiftUI, Å¼e widok musi zostaÄ‡ uniewaÅ¼niony i ponownie wyrenderowany.

07:51
Nie bÄ™dziemy zagÅ‚Ä™biaÄ‡ siÄ™ we wszystkie szczegÃ³Å‚y, ale sedno tkwi w tym, Å¼e trzeba byÅ‚o owinÄ…Ä‡ caÅ‚y widok w widok pomocniczy o nazwie WithViewStore i trzeba byÅ‚o wyraÅºnie opisaÄ‡, jaki stan ma byÄ‡ obserwowany, a nastÄ™pnie otrzymaÄ‡ z powrotem obiekt ViewStore, z ktÃ³rego moÅ¼na byÅ‚o odczytaÄ‡ stan:

```swift
var body: some View {
  WithViewStore(
    self.store, observe: { $0 }
  ) { viewStore in 
    Form {
      Text(viewStore.count.description)
    }
  }
}
```

08:24
Ale jest z tym mnÃ³stwo problemÃ³w:

08:26
Przede wszystkim wymaga to, aby stan byÅ‚ rÃ³wny, a my jeszcze tego nie zrobiliÅ›my. Idealnie byÅ‚oby, gdybyÅ›my nie musieli o tym myÅ›leÄ‡, dopÃ³ki nie bÄ™dziemy gotowi do napisania testÃ³w.
08:33
Po drugie, sprawia to, Å¼e obserwowanie wszystkich stanÃ³w w funkcjach jest zbyt Å‚atwe, co zwykle nie jest tym, co chcemy robiÄ‡.
08:40
Po trzecie, ten kod jest po prostu uciÄ…Å¼liwy w utrzymaniu. Ponosimy dodatkowy poziom wciÄ™Ä‡, mamy dodatkowÄ… koncepcjÄ™ do zrozumienia, a to uciekajÄ…ce zamkniÄ™cie obciÄ…Å¼a kompilator Swift.
08:51
Zapomnijmy na chwilÄ™ o tym, Å¼e wiemy o view stores i dlaczego muszÄ… one istnieÄ‡. BÄ…dÅºmy bardzo naiwni i sprÃ³bujmy uÅ¼yÄ‡ magazynu bezpoÅ›rednio w treÅ›ci widoku. Powiedzmy, pokazujÄ…c aktualnÄ… liczbÄ™ w formularzu:

```swift
var body: some View {
  Form {
    Text(self.store.count.description)
  }
}
```

09:06
CÃ³Å¼, juÅ¼ spotykamy siÄ™ z bÅ‚Ä™dem kompilacji:

09:06
CÃ³Å¼, spotykamy siÄ™ juÅ¼ z bÅ‚Ä™dem kompilacji:

> ğŸ›‘ Referencing subscript 'subscript(dynamicMember:)' on 'Store' wymaga, aby 'CounterFeature.State' byÅ‚ zgodny z 'ObservableState'
>

09:08
A to dlatego, Å¼e wczeÅ›niej nie byÅ‚o dobrym pomysÅ‚em siÄ™ganie bezpoÅ›rednio do sklepu, aby uzyskaÄ‡ dostÄ™p do stanu funkcji. Pozwala to na wyÅ›wietlanie danych w widoku, ktÃ³re nie bÄ™dÄ… automatycznie aktualizowane po zmianie stanu. Powoduje to bÅ‚Ä™dy i usterki w widokach i jest jednym z gÅ‚Ã³wnych problemÃ³w, ktÃ³re SwiftUI chciaÅ‚ rozwiÄ…zaÄ‡ od samego poczÄ…tku.

09:22
Komunikat o bÅ‚Ä™dzie daje nam nawet wskazÃ³wkÄ™, jak moÅ¼emy rozwiÄ…zaÄ‡ ten problem. WyglÄ…da na to, Å¼e nasz stan musi byÄ‡ zgodny z protokoÅ‚em ObservableState. Jest to zupeÅ‚nie nowy protokÃ³Å‚, ktÃ³ry jest dostarczany z Composable Architecture i naleÅ¼y myÅ›leÄ‡ o nim jako o analogicznej koncepcji protokoÅ‚u Observable w Swift, z tÄ… rÃ³Å¼nicÄ…, Å¼e jest on dostosowany do pracy ze strukturami i wyliczeniami w naszej bibliotece.

09:39
Sposobem na dostosowanie struktury do tego protokoÅ‚u jest makro @ObservableState, ktÃ³re jest dostarczane z bibliotekÄ…. Jak widzieliÅ›my wczeÅ›niej, makro @Observable w Swift 5.9 nie dziaÅ‚a na strukturach:

```swift
@Observable
struct State {
  var count = 0
}
```

Powoduje to nastÄ™pujÄ…cy bÅ‚Ä…d:

> ğŸ›‘ '@Observable' nie moÅ¼e byÄ‡ zastosowane do typu struct 'State'.
>

09:51
A wiÄ™c to nie jest poczÄ…tek.

09:52
Ale nasza biblioteka zawiera makro, ktÃ³re jest bardzo podobne do makra Swifta, ale dziaÅ‚a na strukturach:

```swift
@ObservableState
struct State {
  var count = 0
}
```

10:01
Nie tylko to siÄ™ kompiluje, ale nawet widok poniÅ¼ej siÄ™ kompiluje. Po uÅ¼yciu makra @ObservableState na stanie funkcji, natychmiast uzyskujesz nieograniczony dostÄ™p do stanu w swoich sklepach:

```swift
Text(self.store.count.description)
```

10:12
Jest to teraz caÅ‚kowicie w porzÄ…dku, poniewaÅ¼ potajemnie pod maskÄ… struktura Å›ledzi teraz, do jakich pÃ³l uzyskuje siÄ™ dostÄ™p i jakie pola sÄ… mutowane, a to jest automatycznie przekazywane z powrotem do widoku, aby poinformowaÄ‡ go, kiedy naleÅ¼y ponownie wyrenderowaÄ‡.

10:22
Mamy wiÄ™c pewien stan wyÅ›wietlany w widoku, ale nie ma sposobu, aby faktycznie zmieniÄ‡ liczbÄ™. Dodajmy kilka przyciskÃ³w, ktÃ³re wysyÅ‚ajÄ… akcje do sklepu:

```swift
var body: some View {
  Form {
    Text(self.store.count.description)
    Button("Decrement") {
      self.store.send(.decrementButtonTapped) 
    }
    Button("Increment") { 
      self.store.send(.incrementButtonTapped) 
    }
  }
}
```

10:39
Aby uzyskaÄ‡ peÅ‚ny build aplikacji, zaktualizujmy podglÄ…d, aby dostarczyÄ‡ sklep:

```swift
#Preview {
  ContentView(
    store: Store(initialState: CounterFeature.State()) {
      CounterFeature()
    }
  )
}
```

10:50
Jak rÃ³wnieÅ¼ punkt wejÅ›cia aplikacji:

```swift
@main
struct ObservableExplorationsApp: App {
  var body: some Scene {
    WindowGroup {
      ContentView(
        store: Store(
          initialState: CounterFeature.State()
        ) {
          CounterFeature()
        }
      )
    }
  }
}
```

11:04
Mamy teraz zaimplementowanÄ… bardzo podstawowÄ… funkcjÄ™ Composable Architecture i zintegrowaliÅ›my jÄ… z widokiem w najbardziej naiwny moÅ¼liwy sposÃ³b. Po prostu siÄ™gamy bezpoÅ›rednio do sklepu, aby pobraÄ‡ stan i bezpoÅ›rednio wysyÅ‚amy do niego akcje.

11:15
Mamy nadziejÄ™, Å¼e to zadziaÅ‚a i o dziwo absolutnie tak jest. MoÅ¼emy uruchomiÄ‡ to w podglÄ…dzie i zobaczyÄ‡, Å¼e inkrementacja i dekrementacja dziaÅ‚ajÄ… tak, jak mamy nadziejÄ™.



## Jeszcze mÄ…drzejsza obserwacja
11:20
I wÅ‚aÅ›nie w ten sposÃ³b chcieliÅ›my zbudowaÄ‡ Composable Architecture od samego poczÄ…tku. JeÅ›li cofniesz siÄ™ i obejrzysz bardzo wczesne odcinki, aÅ¼ do 2019 roku, zobaczysz, Å¼e koncepcjÄ™ "magazynu widokÃ³w" wprowadziliÅ›my dopiero doÅ›Ä‡ pÃ³Åºno. Zawsze mieliÅ›my nadziejÄ™, Å¼e znajdzie siÄ™ jakiÅ› sposÃ³b, by tego uniknÄ…Ä‡, ale nigdy nie byliÅ›my w stanie rozwiÄ…zaÄ‡ tego problemu. A teraz nowe narzÄ™dzia do obserwacji w Swift 5.9 caÅ‚kowicie otwierajÄ… wrota powodzi.

11:42
Brandon: Ale oczywiÅ›cie ta funkcja nie jest teraz zbyt interesujÄ…ca. Poprawmy jÄ… trochÄ™.

11:47
ZrÃ³bmy to tak, aby widok mÃ³gÅ‚ przeÅ‚Ä…czaÄ‡, czy aktualnie wyÅ›wietla liczbÄ™, czy nie. W poprzednich odcinkach widzieliÅ›my, Å¼e byÅ‚ to Å›wietny sposÃ³b na przetestowanie, jak inteligentne sÄ… nowe narzÄ™dzia do obserwacji, pokazujÄ…c, Å¼e widok zasubskrybuje zmiany stanu, jeÅ›li jest uÅ¼ywany w widoku, ale nastÄ™pnie dynamicznie wypisuje siÄ™ z tych zmian, jeÅ›li stan przestanie byÄ‡ wyÅ›wietlany.

12:07
To byÅ‚o caÅ‚kiem fajne, wiÄ™c zobaczmy, czy Composable Architecture rÃ³wnieÅ¼ moÅ¼e skorzystaÄ‡ z tych sprytnych rozwiÄ…zaÅ„.

12:14
Zamierzam dodaÄ‡ jakiÅ› stan do naszej funkcji, ktÃ³ry okreÅ›la, czy widok powinien wyÅ›wietlaÄ‡ liczbÄ™, czy nie:

```swift
@ObservableState
struct State {
  ...
  var isObservingCount = true
}
```

12:25
A takÅ¼e nowÄ… akcjÄ™ do przeÅ‚Ä…czania tej wartoÅ›ci:

```swift
enum Action {
  ...
  case toggleIsObservingCount
}
```

12:30
I moÅ¼emy Å‚atwo zaimplementowaÄ‡ logikÄ™ w reduktorze:

```swift
case .toggleIsObservingCount:
  state.isObservingCount.toggle()
  return .none
```

12:40
NastÄ™pnie moÅ¼emy zaczÄ…Ä‡ uÅ¼ywaÄ‡ stanu w widoku, aby okreÅ›liÄ‡, czy wyÅ›wietlaÄ‡ licznik:

```swift
if self.store.isObservingCount {
  Text(self.store.count.description)
}
```

12:53
Jak rÃ³wnieÅ¼ dodaÄ‡ przycisk, aby wysÅ‚aÄ‡ nowÄ… akcjÄ™:

```swift
Button("Toggle count observation") {
  self.store.send(.toggleIsObservingCount)
}
```

13:02
Te kilka krokÃ³w to wszystko, co musimy zrobiÄ‡, aby funkcja dziaÅ‚aÅ‚a. MoÅ¼emy uruchomiÄ‡ jÄ… w podglÄ…dzie, aby zobaczyÄ‡, Å¼e wszystko dziaÅ‚a tak, jak byÅ›my tego oczekiwali.

13:23
Co wiÄ™cej, SwiftUI automatycznie obserwuje minimalny stan widoku. Gdy licznik jest widoczny, bÄ™dzie obserwowaÅ‚ zmiany tego stanu, ale gdy wyÅ‚Ä…czymy licznik, widok przestanie ponownie obliczaÄ‡ za kaÅ¼dym razem, gdy zmieni siÄ™ ten stan.

13:37
To niewiarygodne, ale prawdziwe. UmieÅ›Ä‡my _printChanges w widoku:

```swift
var body: some View {
  let _ = Self._printChanges()
  ...
}
```

13:43
I ponownie uruchamiamy podglÄ…d. Za kaÅ¼dym razem, gdy zwiÄ™kszamy lub zmniejszamy liczbÄ™, widzimy, Å¼e ContentView ponownie siÄ™ renderuje:

> ```
> ContentView: @dependencies changed.
> ContentView: @dependencies changed.
> ContentView: @dependencies changed.
> 
> 
> 
> ```

14:00

JeÅ›li wyÅ‚Ä…czymy zliczanie, otrzymamy jeszcze jeden render:

```
ContentView: @dependencies changed.
```

14:13
Ale teraz za kaÅ¼dym razem, gdy zwiÄ™kszamy lub zmniejszamy, nie widzimy niczego drukowanego w konsoli. Widok widzi, Å¼e stan licznika nie jest juÅ¼ uÅ¼ywany w widoku, wiÄ™c nie musi juÅ¼ uniewaÅ¼niaÄ‡ i ponownie renderowaÄ‡, gdy siÄ™ zmieni.

14:31
GdybyÅ›my chcieli osiÄ…gnÄ…Ä‡ takÄ… inteligentnÄ… obserwacjÄ™ za pomocÄ… starych narzÄ™dzi Composable Architecture, musielibyÅ›my zrobiÄ‡ kilka doÅ›Ä‡ dziwnych rzeczy. StworzylibyÅ›my dedykowanÄ… strukturÄ™ stanu widoku, ktÃ³ra przechowywaÅ‚aby opcjonalny stan caÅ‚kowity:

```swift
struct ViewState {
  let count: Int?
  init(state: CounterFeature.State) {
    self.count = state.isObservingCount ? state.count : nil
  }
}
```

15:05
NastÄ™pnie bÄ™dziemy musieli uÅ¼yÄ‡ WithViewStore, aby obserwowaÄ‡ tÄ™ wersjÄ™ stanu:

```swift
WithViewStore(
  self.store, observe: ViewState.init
) { viewStore in 
  ...
}
```

15:18
NastÄ™pnie musimy rozpakowaÄ‡ ten stan:

```swift
if let count = viewStore.count {
  Text(count.description)
}
```

15:30
To naprawdÄ™ dziwaczny sposÃ³b robienia rzeczy. O wiele bardziej naturalne wydaje siÄ™ po prostu wykorzystanie stanu bezpoÅ›rednio w widoku, a widok obserwuje tylko stan, do ktÃ³rego uzyskuje dostÄ™p.

15:44
To absolutnie niesamowite zobaczyÄ‡, jak to naprawdÄ™ dziaÅ‚a.

15:47
Ale czy jesteÅ› gotowy na coÅ› jeszcze bardziej niesamowitego?

15:51
Zmniejszmy cel wdroÅ¼enia tego projektu aÅ¼ do iOS 15. I wybierzmy symulator iOS 15.

16:36
CzyÅ¼ nie byÅ‚oby niesamowicie, gdyby to wszystko w jakiÅ› magiczny sposÃ³b zadziaÅ‚aÅ‚o. Celujemy w wersjÄ™ iOS, ktÃ³ra zostaÅ‚a wydana w 2019 roku, czyli ma ponad 4 lata.

16:53
Ta wersja iOS na dÅ‚ugo wyprzedza iOS 17, Swift 5.9, makra lub jakÄ…kolwiek z tych wymyÅ›lnych funkcji, ktÃ³re naszym zdaniem sÄ… wymagane, aby obserwacja dziaÅ‚aÅ‚a w SwiftUI. WciÄ…Å¼ jest wiele osÃ³b, ktÃ³re muszÄ… obsÅ‚ugiwaÄ‡ iOS 14, 15 i 16, i nie minie jeszcze wiele lat, zanim bÄ™dÄ… mogli obsÅ‚ugiwaÄ‡ iOS 17 i nowsze.

17:21
Czy jest wiÄ™c moÅ¼liwe, Å¼e to zadziaÅ‚a? CÃ³Å¼, projekt siÄ™ kompiluje, wiÄ™c wydaje siÄ™ to naprawdÄ™ obiecujÄ…ce. Ale jeÅ›li uruchomimy go w symulatorze, zobaczymy, Å¼e niestety nie dziaÅ‚a. Ale zauwaÅ¼my, Å¼e otrzymujemy fioletowe ostrzeÅ¼enie w Xcode:

> ğŸŸ£ RuntimeWarnings.swift:4 Uzyskano dostÄ™p do obserwowalnego stanu, ale nie jest on Å›ledzony. ÅšledÅº zmiany w stanie przechowywania w "WithPerceptionTracking", aby zapewniÄ‡ dostarczanie aktualizacji widoku.
>

17:48
Okazuje siÄ™, Å¼e jest jeden dodatkowy krok, ktÃ³ry naleÅ¼y wykonaÄ‡, aby to dziaÅ‚aÅ‚o na urzÄ…dzeniach przed iOS 17, a biblioteka zwykle moÅ¼e wykryÄ‡, kiedy nie robisz tego poprawnie, aby CiÄ™ o tym poinformowaÄ‡.

18:05
Wszystko, co musimy zrobiÄ‡, to opakowaÄ‡ nasz widok w ten specjalny nowy rodzaj widoku o nazwie WithPerceptionTracking:

```swift
struct ContentView: View {
  ...
  var body: some View {
    WithPerceptionTracking {
      let _ = print("\(Self.self).body")
      ...
    }
  }
}
```

18:23
Widok WithPerceptionTracking jest czÄ™Å›ciÄ… wewnÄ™trznej biblioteki w Composable Architecture, ktÃ³ra ma nasz tylny port frameworka Observation, dziÄ™ki czemu dziaÅ‚a na pre-iOS 17. Nazywamy jÄ… Perception, a pewnego dnia moÅ¼emy nawet wydzieliÄ‡ jÄ… z Composable Architecture, aby mogÅ‚a byÄ‡ rÃ³wnieÅ¼ uÅ¼ywana w waniliowych aplikacjach SwiftUI. Ale to bÄ™dzie musiaÅ‚o poczekaÄ‡ na inny dzieÅ„.

18:44
I to wszystko, czego potrzeba, aby widok automatycznie obserwowaÅ‚ kaÅ¼dy stan, do ktÃ³rego uzyskano dostÄ™p w widoku. MoÅ¼emy uruchomiÄ‡ aplikacjÄ™ w symulatorze i zobaczyÄ‡, Å¼e wszystko dziaÅ‚a w widoku, a ponadto widok kontynuuje ponowne obliczanie w najbardziej minimalny moÅ¼liwy sposÃ³b. JeÅ›li nie wyÅ›wietlamy liczby w widoku, to zmiany liczby nie spowodujÄ… ponownego obliczenia widoku. Wszystko to dziaÅ‚a na urzÄ…dzeniu z systemem iOS 15. A gdybyÅ›my mieli zainstalowany symulator iOS 14 lub nawet iOS 13, zobaczylibyÅ›my, Å¼e dziaÅ‚a nawet na tych starszych platformach.

19:23
I moÅ¼e siÄ™ to wydawaÄ‡ krokiem wstecz, Å¼e musieliÅ›my uÅ¼yÄ‡ tego widoku WithPerceptionTracking do zawiniÄ™cia naszego gÅ‚Ã³wnego widoku. W koÅ„cu byliÅ›my w stanie caÅ‚kowicie pozbyÄ‡ siÄ™ koncepcji WithViewStore w iOS 17, a wiÄ™c czy nie jest to bummer, Å¼e potrzebujemy tego w pre-iOS 17?

19:44
CÃ³Å¼, osobiÅ›cie nie uwaÅ¼amy, Å¼e to taka wielka sprawa. Nie jest to tak naprawdÄ™ podobne do WithViewStore, ktÃ³rego musieliÅ›my uÅ¼ywaÄ‡ wczeÅ›niej:

19:51
Po pierwsze, nie musisz dostarczaÄ‡ mu sklepu i wyraÅºnie mÃ³wiÄ‡, jaki stan chcesz obserwowaÄ‡. Wszystko to jest zaÅ‚atwione za ciebie.
20:06
Po drugie, koÅ„cowe zamkniÄ™cie nie przyjmuje argumentu i pomaga nie obciÄ…Å¼aÄ‡ kompilatora Swift.
20:36
Po trzecie, jeÅ›li przypadkowo zapomnisz uÅ¼yÄ‡ tego widoku, otrzymasz pomocne ostrzeÅ¼enie w Xcode, informujÄ…ce, Å¼e nie jest to wÅ‚aÅ›ciwe.
20:46
I po czwarte, jest to potrzebne tylko wtedy, gdy obsÅ‚ugujesz urzÄ…dzenia sprzed iOS 17, a my uwaÅ¼amy, Å¼e to niewielka cena za posiadanie caÅ‚ej mocy obserwacji na wyciÄ…gniÄ™cie rÄ™ki bez koniecznoÅ›ci czekania lat.
## NastÄ™pnym razem: Naiwna obserwacja
21:09
OK, to byÅ‚a fajna zapowiedÅº tego, co zaoferujÄ… ostateczne narzÄ™dzia. Nie sÄ…dzÄ™ jednak, by nasi widzowie oglÄ…dali teraz ten odcinek tylko po to, by dowiedzieÄ‡ siÄ™, jak korzystaÄ‡ z nowych narzÄ™dzi. MogÄ… sprawdziÄ‡ gaÅ‚Ä…Åº observation-beta oraz wszystkie dema i studia przypadkÃ³w, aby uzyskaÄ‡ te informacje.

21:25
Stephen: Zamiast tego myÅ›lÄ™, Å¼e nasi widzowie sÄ… o wiele bardziej zainteresowani dowiedzeniem siÄ™, jak osiÄ…gnÄ™liÅ›my to wszystko w bibliotece. To wÅ‚aÅ›nie tam moÅ¼emy pochwaliÄ‡ siÄ™ naprawdÄ™ zaawansowanymi technikami w jÄ™zyku Swift i pomÃ³c ludziom lepiej zrozumieÄ‡, jak dziaÅ‚a biblioteka. JednÄ… z najlepszych rzeczy w Composable Architecture jest nie tylko to, Å¼e jest to przyjemna w uÅ¼yciu biblioteka, ale takÅ¼e to, Å¼e prawie kaÅ¼da decyzja, ktÃ³ra zostaÅ‚a podjÄ™ta przy jej projektowaniu, jest dobrze udokumentowana w tej serii filmÃ³w. I nie zamierzamy tego teraz zmieniaÄ‡.

21:50
Zacznijmy wiÄ™c od prÃ³by naiwnego zintegrowania frameworka Observation z Composable Architecture w jego ostatniej publicznej wersji i zobaczmy, jak daleko uda nam siÄ™ zajÅ›Ä‡, zanim napotkamy problemy. PomoÅ¼e nam to ustaliÄ‡, gdzie musimy odejÅ›Ä‡ od narzÄ™dzi Apple, aby osiÄ…gnÄ…Ä‡ nasze cele.



# Obserwowalna architektura: Obserwowanie nawigacji

Odcinek #264 - 15 stycznia 2024 - Tylko dla subskrybentÃ³w

Obserwacja pozwoliÅ‚a nam pozbyÄ‡ siÄ™ wielu wrapperÃ³w widoku, ktÃ³rych wymagaÅ‚a architektura komponowalna, na rzecz waniliowych widokÃ³w SwiftUI, ale nadal polegamy na zoo modyfikatorÃ³w widoku, aby sterowaÄ‡ nawigacjÄ…. ZastanÃ³wmy siÄ™ ponownie nad wszystkimi tymi pomocnikami i zobaczmy, czy moÅ¼emy je zamieniÄ‡ na prostsze, waniliowe modyfikatory widoku SwiftUI.

## Wprowadzenie
00:05
Brandon: PozbywajÄ…c siÄ™ naszego wyspecjalizowanego pomocnika widoku, ForEachStore, odblokowaliÅ›my wszystkie nowe super moce podczas modelowania list funkcji w architekturze komponowalnej. MoÅ¼emy korzystaÄ‡ ze wszystkich wymyÅ›lnych interfejsÃ³w API kolekcji, ktÃ³re sÄ… dostarczane ze standardowÄ… bibliotekÄ…, aby pokroiÄ‡ i pokroiÄ‡ w kostkÄ™ kolekcjÄ™ danych do wyÅ›wietlenia w interfejsie uÅ¼ytkownika, a wszystko jest nadal renderowane w moÅ¼liwie najbardziej minimalny sposÃ³b.

00:26
PozbyliÅ›my siÄ™ wiÄ™c WithViewStore, IfLetStore, SwitchStore, CaseLet i ForEachStore. ByÅ‚y to jedyne dedykowane widoki, ktÃ³re biblioteka dostarczaÅ‚a w celu radzenia sobie z opcjonalnym stanem, stanem wyliczenia i stanem kolekcji.

00:40
Stephen: Istnieje jednak inna klasa pomocnikÃ³w dostarczanych z bibliotekÄ…, ktÃ³re rÃ³wnieÅ¼ nie sÄ… juÅ¼ potrzebne w Å›wiecie obserwacji Swift, a sÄ… to modyfikatory widoku nawigacji. Obecnie musimy utrzymywaÄ‡ caÅ‚e zoo modyfikatorÃ³w widoku, ktÃ³re naÅ›ladujÄ… te dostarczane z waniliowym SwiftUI, ale dostosowane specjalnie do architektury kompozytowej. Obejmuje to modyfikatory dla arkuszy, wyskakujÄ…cych okienek, peÅ‚noekranowych okÅ‚adek, drÄ…Å¼enia, stosÃ³w nawigacyjnych i innych.

01:07
CÃ³Å¼, o dziwo, moÅ¼emy przestaÄ‡ uÅ¼ywaÄ‡ wszystkich tych pomocnikÃ³w i zamiast tego po prostu uÅ¼yÄ‡ modyfikatorÃ³w widoku waniliowego SwiftUI. A wszystko to dziÄ™ki narzÄ™dziom do obserwacji w Swift.

01:16
Przyjrzyjmy siÄ™ im.

## Nawigacja: podsumowanie i przemyÅ›lenia
01:20
Aby to zbadaÄ‡, przyjrzymy siÄ™ przypadkowi testowemu integracji, ktÃ³remu przyjrzeliÅ›my siÄ™ nieco wczeÅ›niej i ktÃ³ry juÅ¼ nieco poprawiliÅ›my, o nazwie PresentationTestCase.swift. Ä†wiczy on wiele subtelnych przypadkÃ³w brzegowych podczas prezentacji funkcji przy uÅ¼yciu opcji i wyliczeÅ„.

01:34
MoÅ¼emy uruchomiÄ‡ podglÄ…d, aby zobaczyÄ‡, do czego jest zdolny. IstniejÄ… przyciski do prezentacji funkcji podrzÄ™dnej na rÃ³Å¼ne sposoby, takie jak popover, okÅ‚adka peÅ‚noekranowa i arkusz. W ramach kaÅ¼dej z tych form nawigacji moÅ¼na wchodziÄ‡ w interakcje z funkcjÄ… podrzÄ™dnÄ… jako jednostkÄ… odizolowanÄ… od elementu nadrzÄ™dnego. Ale w arkuszu moÅ¼emy sprawiÄ‡, by rodzic obserwowaÅ‚ stan dziecka, gdy arkusz jest otwarty.

01:59
To pozornie proste demo stawia pewne interesujÄ…ce wyzwania zwiÄ…zane z upewnieniem siÄ™, Å¼e widoki obserwujÄ… minimalnÄ… moÅ¼liwÄ… iloÅ›Ä‡ stanu. Chcemy, aby domena nadrzÄ™dna mogÅ‚a dynamicznie zaglÄ…daÄ‡ do stanu elementu podrzÄ™dnego i obserwowaÄ‡ ten stan tylko podczas uzyskiwania dostÄ™pu do niego w widoku. Przyjrzyjmy siÄ™ kodowi, aby zobaczyÄ‡, jak jest to obecnie realizowane.

02:18
Reduktor funkcji ma opcjonalny stan do kierowania prezentacjÄ… tylko arkusza, a nastÄ™pnie opcjonalny stan wyliczeniowy do kierowania prezentacjÄ… wzajemnie wykluczajÄ…cego siÄ™ popover i peÅ‚noekranowej okÅ‚adki:

```swift
@Reducer
struct Feature {
  struct State: Equatable {
    var isObservingChildCount = false
    @PresentationState var destination: Destination.State?
    @PresentationState var sheet: BasicsView.Feature.State?
  }
  â€¦
  @Reducer
  struct Destination {
    enum State: Equatable {
      case fullScreenCover(BasicsView.Feature.State)
      case popover(BasicsView.Feature.State)
    }
    â€¦
  }
}
```

