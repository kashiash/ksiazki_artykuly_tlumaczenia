# Naucz się programować w dziesięć lat

# Peter Norvig

http://norvig.com/21-days.html

*Uwaga oryginalny artykuł ma już kilkanaście lat, więc niektore linki,  języki itp. proponowane przez autora mogą już nie być aktualne.*

## Dlaczego wszyscy tak się spieszą?

Wejdź do dowolnej księgarni, a zobaczysz jak nauczysz się Javy w 24 godziny obok nieskończonej liczby wariacji oferujących naukę C, SQL, Ruby, algorytmów itp. w kilka dni lub godzin. Przeszukanie zaawansowane w Amazonie pod hasłem [tytuł: naucz się, sam, godziny, od: 2000] dało wynik 512 książek. Spośród dziesięciu najlepszych, dziewięć to książki programistyczne (jedna dotyczy księgowości). Podobne wyniki uzyskano, zamieniając "naucz się" na "naucz się" lub "godziny" na "dni".
Wnioskiem jest, że albo ludzie bardzo się spieszą, żeby nauczyć się programować, albo programowanie jest jakoś niezwykle łatwe do nauki w porównaniu z czymkolwiek innego. Felleisen et al. przytaczają ten trend w swojej książce "How to Design Programs", mówiąc: "Złe programowanie jest łatwe. Głupcy mogą się tego nauczyć w 21 dni, nawet jeśli są głupi". Komiks Abtruse Goose także ma swoje zdanie na ten temat.

## Przeanalizujmy, co może oznaczać taki tytuł jak "Naucz się C++ w 24 godziny":

Naucz się: W ciągu 24 godzin nie będziesz miał czasu napisać kilku istotnych programów i uczyć się na ich podstawie swoich sukcesów i porażek. Nie będziesz miał czasu pracować z doświadczonym programistą i zrozumieć, jak to jest żyć w środowisku C++. W skrócie, nie będziesz miał czasu na naukę zbyt wiele. Tak więc książka może mówić tylko o powierzchownej znajomości, a nie o głębokim zrozumieniu. Jak powiedział Alexander Pope, "nieco wiedzy jest rzeczą niebezpieczną".
C++: W ciągu 24 godzin możesz nauczyć się niektórych składni C++ (jeśli już znasz inny język), ale nie nauczysz się zbyt wiele o tym, jak używać tego języka. W skrócie, jeśli byłeś na przykład programistą Basic, możesz nauczyć się pisać programy w stylu Basic, używając składni C++, ale nie nauczysz się, do czego C++ jest naprawdę dobre (i złe). Jeden możliwy punkt to taki, że musisz nauczyć się odrobinę C++ (lub bardziej prawdopodobnie czegoś takiego jak JavaScript lub Processing), ponieważ musisz współpracować z istniejącym narzędziem, aby wykonać określone zadanie. Ale wtedy nie uczysz się programować; uczysz się wykonywać to zadanie.
w 24 godziny: Niestety, to nie wystarczy, jak pokazuje następny fragment.

## Naucz się programować w ciągu dziesięciu lat

Badacze (Bloom (1985), Bryan & Harter (1899), Hayes (1989), Simmon & Chase (1973)) wykazali, że zajmuje około dziesięciu lat, aby zostać ekspertem w różnorodnych dziedzinach, takich jak gra w szachy, komponowanie muzyki, obsługa telegrafu, malarstwo, gra na pianinie, pływanie, tenis oraz badania z zakresu neuropsychologii i topologii. Kluczem jest celowa praktyka: nie tylko powtarzanie czynności wielokrotnie, ale również stawianie sobie wyzwań poprzez zadania, które są nieco ponad Twoimi obecnymi umiejętnościami, próbowanie ich, analizowanie własnego wykonania podczas i po działaniu oraz poprawianie wszelkich błędów. Następnie powtórz. I powtórz jeszcze raz. Nie wydaje się istnieć żadnych prawdziwych skrótów: nawet Mozart, który był cudownym dzieckiem muzycznym w wieku 4 lat, potrzebował kolejnych 13 lat, zanim zaczął tworzyć muzykę na światowym poziomie. W innej dziedzinie, The Beatles zdawało się, że pojawiły się na scenie z serią numerów jeden i występem w programie Eda Sullivana w 1964 roku. Ale grali w małych klubach w Liverpoolu i Hamburgu od 1957 roku, i mimo że mieli masowy urok już na początku, ich pierwszym wielkim sukcesem krytycznym było wydanie płyty "Sgt. Pepper's Lonely Hearts Club Band" w 1967 roku.

`Malcolm Gladwell` upowszechnił tę ideę, chociaż skupił się na 10 000 godzinach, a nie 10 latach. `Henri Cartier-Bresson` (1908-2004) miał inną miarę: "Twoje pierwsze 10 000 fotografii to Twoje najgorsze" (Nie przewidział, że z cyfrowymi aparatami niektórzy ludzie mogą osiągnąć ten wynik w tydzień). Prawdziwa ekspertyza może trwać całe życie: `Samuel Johnson` (1709-1784) powiedział: "Doskonałość w każdej dziedzinie może być osiągnięta tylko przez pracę życia; nie może być osiągnięta w niższej cenie". A Chaucer (1340-1400) narzekał: "życie takie krótkie, rzemiosło tak długie do nauki". Hipokrates (około 400 p.n.e.) jest znany z cytatów: "Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile", co można przetłumaczyć jako "Sztuka długa, życie krótkie, okazja ulotna, eksperyment zdradliwy, osąd trudny". Oczywiście żadna pojedyncza liczba nie może być ostateczną odpowiedzią: nie wydaje się rozsądne zakładać, że wszystkie umiejętności (np. programowanie, gra w szachy, gra w warcaby i granie na instrumentach muzycznych) wymagają dokładnie takiej samej ilości czasu, aby je opanować, ani że wszyscy ludzie będą potrzebować dokładnie tyle samo czasu. Jak to Prof. K. Anders Ericsson ujął, "W większości dziedzin jest zadziwiające, ile czasu nawet najbardziej utalentowani ludzie potrzebują, aby osiągnąć najwyższe poziomy wydajności. Liczba 10 000 godzin daje tylko poczucie, że mówimy o latach pracy od 10 do 20 godzin tygodniowo, które ci, których niektórzy uważaliby za najbardziej urodzonych talentów, nadal potrzebują, aby osiągnąć najwyższy poziom.

Tak więc chcesz być programistą

Oto moja recepta na sukces w programowaniu:

1. **Zainteresuj** się programowaniem i rób to, ponieważ sprawia to przyjemność. Upewnij się, że to nadal sprawia tyle frajdy, że będziesz gotów/a poświęcić dziesięć lat lub 10 000 godzin na naukę.
2. **Programuj**. Najlepszym rodzajem nauki jest nauka przez działanie. Aby to ująć bardziej technicznie, "maksymalny poziom wydajności jednostek w danej dziedzinie nie jest osiągany automatycznie w wyniku rozszerzonego doświadczenia, ale poziom ten może być zwiększony nawet przez bardzo doświadczonych ludzi dzięki świadomym wysiłkom mającym na celu poprawę" (str. 366) oraz "najefektywniejsze uczenie wymaga dobrze określonego zadania o odpowiednim stopniu trudności dla konkretnej osoby, informacyjnego feedbacku oraz możliwości powtórek i korekty błędów" (str. 20-21). Książka "Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life" jest ciekawym odniesieniem do tego podejścia.
3. **Rozmawiaj z innymi programistami**; czytaj inne programy. To jest ważniejsze niż jakakolwiek książka czy kurs szkoleniowy.
4. Jeśli chcesz, spędź cztery lata na **studiach** (lub więcej na studiach magisterskich). Daje to dostęp do pewnych prac wymagających kwalifikacji, a także głębsze zrozumienie dziedziny, ale jeśli nie lubisz szkoły, możesz (z odrobiną zaangażowania) zdobyć podobne doświadczenie samodzielnie lub w pracy. W każdym przypadku samą wiedzę książkową to za mało. "Edukacja z zakresu informatyki nie może uczynić nikogo ekspertem programowania tak samo, jak nauka o pędzlach i pigmentach nie uczyni nikogo ekspertem malarzem" twierdzi Eric Raymond, autor "The New Hacker's Dictionary". Jeden z najlepszych programistów, jakiego kiedykolwiek zatrudniłem, miał tylko świadectwo ukończenia szkoły średniej; stworzył wiele świetnych oprogramowań, prowadzi swoją własną grupę dyskusyjną i na tyle dużo zarobił dzięki opcjom na akcje, że mógł sobie kupić własny klub nocny.
5. **Pracuj nad projektami z innymi** programistami. Bądź najlepszym programistą w niektórych projektach; bądź najgorszym w innych. Kiedy jesteś najlepszy, możesz przetestować swoje umiejętności w prowadzeniu projektu i zainspirować innych swoją wizją. Kiedy jesteś najgorszy, uczysz się od mistrzów, dowiadując się, co robią, a czego nie lubią robić (bo zmuszają cię do tego).
6. Pracuj nad **projektami napisanymi przez innych** programistów. Zrozum programy napisane przez innych. Zobacz, co jest potrzebne, aby je zrozumieć i naprawić, gdy oryginalni programiści nie są obecni. Zastanów się, jak zaprojektować swoje programy, aby ułatwić pracę tym, którzy będą je utrzymywać po Tobie.
7. Naucz się przynajmniej pół tuzina **języków programowania**. Obejmij jeden język, który kładzie nacisk na abstrakcje klas (np. Java lub C++), jeden, który kładzie nacisk na abstrakcje funkcjonalne (np. Lisp lub ML lub Haskell), jeden, który obsługuje abstrakcje składniowe (np. Lisp), jeden, który obsługuje deklaratywne specyfikacje (np. Prolog lub szablony C++) oraz jeden, który kładzie nacisk na równoległość (np. Clojure lub Go).
8. Pamiętaj, że w "informatyce" jest "**komputer**". Wiedz, jak długo trwa twojemu komputerowi wykonanie instrukcji, pobranie słowa z pamięci (z i bez trafienia w pamięć podręczną), odczytanie kolejnych słów z dysku oraz przesunięcie się do nowego miejsca na dysku. (Odpowiedzi są tutaj) http://norvig.com/21-days.html#answers.
9. Zaangażuj się w wysiłki **standaryzacyjne** dotyczące języków programowania. Może to być komitet ANSI C++, albo decydowanie, czy lokalny styl kodowania będzie miał wcięcia o długości 2 czy 4 spacji. W każdym przypadku dowiesz się, co inni ludzie lubią w języku, jak bardzo się tego uczują i być może nawet trochę dlaczego tak się czują.
10. Miej dość rozsądku, aby jak najszybciej **zrezygnować** z udziału w wysiłkach standaryzacyjnych języka programowania.

Mając to wszystko na uwadze, warto zastanowić się, jak daleko można zajść tylko dzięki nauce z książek. Przed narodzeniem mojego pierwszego dziecka przeczytałem wszystkie poradniki "Jak być rodzicem", ale mimo to czułem się jak nieudolny nowicjusz. 30 miesięcy później, gdy zbliżał się termin narodzin mojego drugiego dziecka, wróciłem do książek dla przypomnienia sobie? Nie. Zamiast tego polegałem na własnym doświadczeniu, które okazało się dla mnie o wiele bardziej przydatne i uspokajające niż tysiące stron napisanych przez ekspertów.

Fred Brooks w swoim eseju "No Silver Bullet" zidentyfikował trójczłonowy plan znalezienia doskonałych projektantów oprogramowania:

1. Systematycznie identyfikuj najlepszych projektantów jak najwcześniej.
2. Przydziel mentorów zawodowej kariery, którzy będą odpowiedzialni za rozwój perspektywy i starannie prowadź ich dokumentację kariery.
3. Stwarzaj możliwości interakcji i stymulowania wzajemnego rozwoju projektantów.

Założenie jest takie, że niektórzy ludzie już mają cechy niezbędne do bycia doskonałymi projektantami; zadaniem jest odpowiednie ich zachęcenie. Alan Perlis wyraził to bardziej zwięźle: "Każdy może nauczyć się rzeźbić: Michelangelo musiałby nauczyć się, jak tego nie robić. Tak samo jest z wielkimi programistami". Perlis mówi, że wielcy mają jakąś wewnętrzną jakość, która przewyższa ich szkolenie. Skąd jednak pochodzi ta jakość? Czy jest wrodzona? Czy może ją rozwijają poprzez staranność? Jak to ujął Auguste Gusteau (fikcyjny szef kuchni w filmie "Ratatuj"), "każdy może gotować, ale tylko nieustraszeni mogą być wielcy". Ja uważam to bardziej za gotowość poświęcenia dużej części swojego życia na celową praktykę. Ale być może "nieustraszony" to sposób na podsumowanie tego. Lub jak mówi krytyk Gusteau, Anton Ego: "Nie każdy może stać się wielkim artystą, ale wielki artysta może pochodzić z dowolnego miejsca".

Więc śmiało kup tę książkę o Javie/Rubym/Javascript/PHP; prawdopodobnie będziesz z niej miało jakąś korzyść. Ale nie zmienisz swojego życia ani swojej prawdziwej ogólnej wiedzy jako programista w ciągu 24 godzin czy 21 dni. A może zamiast tego warto ciężko pracować, aby stale poprawiać się przez 24 miesiące? No cóż, teraz zaczynasz osiągać coś naprawdę wartościowego...

## Referencje:

- Bloom, Benjamin (red.) *Developing Talent in Young People*, Ballantine, 1985.

- Brooks, Fred, *No Silver Bullets*, IEEE Computer, vol. 20, nr 4, 1987, s. 10-19.

- Bryan, W.L. & Harter, N. "Studies on the telegraphic language: The acquisition of a hierarchy of habits." *Psychology Review*, 1899, 8, 345-375.

- Hayes, John R., *Complete Problem Solver*, Lawrence Erlbaum, 1989.

- Chase, William G. & Simon, Herbert A. "Perception in Chess." *Cognitive Psychology*, 1973, 4, 55-81.

- Lave, Jean, *Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life*, Cambridge University Press, 1988.

## Odpowiedzi:

Dane dotyczące czasów różnych operacji na typowym komputerze:

| Operacja                                      | Czas (nanosekundy)      |
| --------------------------------------------- | ----------------------- |
| Wykonanie typowej instrukcji                  | 1 ns                    |
| Pobranie z pamięci podręcznej L1              | 0,5 ns                  |
| Błędne przewidywanie skoku                    | 5 ns                    |
| Pobranie z pamięci podręcznej L2              | 7 ns                    |
| Blokada/Mutex (blokowanie/odblokowanie)       | 25 ns                   |
| Pobranie z pamięci głównej                    | 100 ns                  |
| Wysłanie 2 KB danych przez sieć 1 Gbps        | 20,000 ns (20 μs)       |
| Odczyt 1 MB sekwencyjnie z pamięci            | 250,000 ns (250 μs)     |
| Pobranie z nowej lokalizacji dysku (szukanie) | 8,000,000 ns (8 ms)     |
| Odczyt 1 MB sekwencyjnie z dysku              | 20,000,000 ns (20 ms)   |
| Wysłanie pakietu z USA do Europy i z powrotem | 150,000,000 ns (150 ms) |

## Wybór Języka Programowania

Wielu ludzi pyta, od którego języka programowania powinni zacząć. Nie ma jednoznacznej odpowiedzi, ale warto wziąć pod uwagę następujące kwestie:

1. **Korzystaj z opinii znajomych.** Kiedy ktoś pyta, "który system operacyjny powinienem wybrać, Windows, Unix czy Mac?", moja odpowiedź zazwyczaj brzmi: "używaj tego, co używają twoi znajomi". Korzyści, jakie odnosisz, ucząc się od swoich przyjaciół, zrównoważą ewentualne różnice między systemami operacyjnymi lub językami programowania. Zastanów się również nad swoimi przyszłymi znajomościami: społecznością programistów, której będziesz częścią, jeśli będziesz kontynuować naukę. Czy wybrany przez ciebie język programowania ma duże i rosnące grono użytkowników, czy może małe i malejące? Czy są dostępne książki, strony internetowe i fora online, gdzie można uzyskać odpowiedzi? Czy lubisz ludzi uczestniczących w tych forach?

2. **Wybierz prosty język.** Języki programowania takie jak C++ czy Java są zaprojektowane dla profesjonalnego rozwoju przez duże zespoły doświadczonych programistów, którzy martwią się efektywnością czasu działania swojego kodu. W rezultacie mają one skomplikowane elementy stworzone z myślą o tych okolicznościach. Ty uczysz się programować. Nie potrzebujesz tej komplikacji. Chcesz języka, który został zaprojektowany tak, aby był łatwy do nauki i zapamiętania przez nowego programistę.

3. **Baw się.** Który sposób nauki gry na pianinie wybrałbyś: normalny, interaktywny sposób, w którym słyszysz każdą nutę zaraz po naciśnięciu klawisza, czy tryb "wsadowy", w którym słyszysz nuty dopiero po zakończeniu całej piosenki? Oczywiście, tryb interaktywny ułatwia naukę zarówno gry na pianinie, jak i programowania. Upieraj się przy wyborze języka z trybem interaktywnym i używaj go.

Biorąc pod uwagę te kryteria, moje zalecenia dotyczące pierwszego języka programowania to Python lub Scheme. Innym wyborem może być JavaScript, nie dlatego, że jest idealnie zaprojektowany dla początkujących, ale dlatego, że istnieje wiele dostępnych online samouczków, takich jak tutorial Khan Academy. Ale twoje okoliczności mogą być inne, i istnieją inne dobre wybory. Jeśli jesteś jednocyfrowym dzieckiem, możesz wziąć pod uwagę także Alice, Squeak lub Blockly (starsi uczący się również mogą z nich skorzystać). Ważne jest, abyś dokonał wyboru i zaczął naukę.

##  Książki i Inne Źródła

Wiele osób pytało, jakie książki i strony internetowe powinni wybrać do nauki. Powtarzam, że "samodzielna nauka z książek nie będzie wystarczająca", ale mogę polecić następujące pozycje:

**Scheme:**
- *Structure and Interpretation of Computer Programs* (Abelson & Sussman) to prawdopodobnie najlepsze wprowadzenie do nauki informatyki, które uczy programowania jako sposobu zrozumienia informatyki. Można obejrzeć online nagrania wykładów z tej książki, a także pełny tekst jest dostępny online. Książka jest wymagająca i odrzuci niektórych ludzi, którzy być może byliby sukcesywni przy innym podejściu.
- *How to Design Programs* (Felleisen et al.) to jedna z najlepszych książek na temat projektowania programów w elegancki i funkcjonalny sposób.

**Python:**
- *Python Programming: An Intro to CS* (Zelle) to dobre wprowadzenie do nauki programowania w Pythonie.
- Na Python.org dostępnych jest wiele samouczków online.

**Oz:**
- *Concepts, Techniques, and Models of Computer Programming* (Van Roy & Haridi) jest uważane przez niektórych za dzisiejszego następcę Abelsona i Sussmana. To przewodnik przez główne idee programowania, obejmujący szerszy zakres niż Abelson & Sussman, ale być może łatwiejszy do przeczytania i zrozumienia. Książka ta używa języka Oz, który nie jest powszechnie znany, ale stanowi podstawę nauki innych języków.

## Notatki

T. Capey zwraca uwagę, że strona książki "Complete Problem Solver" na Amazonie teraz zawiera również pozycje "Teach Yourself Bengali in 21 days" i "Teach Yourself Grammar and Style" w sekcji "Customers who shopped for this item also shopped for these items". Wydaje się, że duża część osób, które przeglądają tę książkę, trafia na nią z tej strony. Dzięki Rossowi Cohenowi za pomoc w kwestii Hipokratesa.