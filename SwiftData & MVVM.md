SwiftData & MVVM 

> So let's start by looking at our model at the very top of this file. So it is annotated with add model, which makes it usable with Swift data. It's just a very simple location class with a single attribute being a name string. So absolutely nothing fancy here inside of the model. Then I have created a view model, which is also just a class, but annotated it with the add observable macro, which is part of the observation framework, in case you didn't know. That is also implicitly imported through Swift data, so you don't need to explicitly import observation. If you have already imported Swift data, you can get rid of that. Now, here's one of the first issues for W3C, is things that need to get figured out down the road, which is similar to how it had to be handled in Core Data. We once again have a model context. We also had a context in Core Data. Now in Swift data, we have the model context. There are probably a bunch of different ways of giving your view model access to that context. I could imagine having a shared instance of that context and just accessing that, similar to how you would have your persistence controller.shared instance in Core Data. You could use a dependency injection approach, using, for example, a framework that has a property wrapper to get your dependencies from, which could be a great idea, in my opinion. I have gone with the simplest approach in this example, but you're free to try out whatever works for you. So I just have an optional model context here, which is nil. 

SwiftData & MVVM

Zaczynamy od przyjrzenia się naszemu modelowi na samej górze tego pliku. Jest on oznaczony adnotacją `@addModel`, co sprawia, że jest użyteczny w kontekście SwiftData. To jest bardzo prosty model klasy `Location` z jednym atrybutem będącym łańcuchem znaków `name`. Tak więc wewnątrz modelu nie ma niczego skomplikowanego. Następnie stworzyłem widok modelu (`viewModel`), który również jest klasą, ale oznaczoną adnotacją `@addObservable`, która jest częścią frameworku obserwacji, na wypadek, gdybyś tego nie wiedział. Jest to również niejawnie importowane poprzez SwiftData, więc nie musisz explicite importować `Observation`. Jeśli już zaimportowałeś SwiftData, możesz się tego pozbyć.

Teraz pojawia się jedno z pierwszych problemów dla W3C, które będą musiały być rozwiązane w przyszłości, co jest podobne do tego, jak musiało być to obsłużone w Core Data. Mamy ponownie kontekst modelu. Mieliśmy też kontekst w Core Data. Teraz w SwiftData mamy kontekst modelu. Istnieje prawdopodobnie wiele różnych sposobów, aby umożliwić twojemu widokowi modelu dostęp do tego kontekstu. Mogę sobie wyobrazić, że można by utworzyć współdzieloną instancję tego kontekstu i uzyskiwać do niej dostęp, podobnie jak w przypadku współdzielonej instancji `persistenceController` w Core Data. Można zastosować podejście wstrzykiwania zależności, używając na przykład frameworku, który ma property wrapper do uzyskiwania zależności, co moim zdaniem może być świetnym pomysłem. W tym przykładzie poszedłem najprostszą drogą, ale jesteś wolny, aby wypróbować to, co dla ciebie działa najlepiej. Więc mam tutaj opcjonalny kontekst modelu, który jest równy `nil`.

> When creating the view model, I'm just setting this to be the context that we are actually using. And I'm doing that inside of my view, so I'm grabbing the context from the environment. I have a state of my view model. This is how you're using view models now. No more state objects. You can use state or bindable, but state should be fine in this case, since we're not binding to any values in the view model. And then in the onAppear of this list over here, I'm just telling my view model to use the model context from the SwiftUI environment. So this is just the simplest setup, but we will have to deal with options here. Dependency injection is probably a better approach. Next, the view model has an array of locations. You might notice here that it is not annotated with addQuery, because addQuery only works in views. So this magical property wrapper here that I so much appreciate and already appreciate it as a fetchRequestPropertyWrapper at core data is not available to us when we're using MVVM. Instead, I wrote a fetchLocations function here, which creates a fetch descriptor. 

Przy tworzeniu widoku modelu po prostu ustawiam to na kontekst, który rzeczywiście używamy. Robię to wewnątrz mojego widoku, więc pobieram kontekst z otoczenia. Mam stan mojego widoku modelu. Tak właśnie teraz używasz widoków modeli. Nie ma już obiektów stanu (`@StateObject`). Możesz użyć `@State` lub `@Bindable`, ale w tym przypadku powinien wystarczyć `@State`, ponieważ nie jesteśmy powiązani z żadnymi wartościami w widoku modelu. A następnie w modyfikatorze `onAppear` na tej liście mówię po prostu mojemu widokowi modelu, żeby używał kontekstu modelu ze środowiska SwiftUI. Więc to jest po prostu najprostsza konfiguracja, ale będziemy musieli się zmierzyć z opcjami tutaj. Wstrzykiwanie zależności jest prawdopodobnie lepszym podejściem.

Następnie widok modelu ma tablicę lokalizacji. Możesz zauważyć, że nie jest ona oznaczona adnotacją `@addQuery`, ponieważ `@addQuery` działa tylko w widokach. Więc ten magiczny property wrapper, który tak bardzo cenimy i który już ceniliśmy jako `@FetchRequest` w Core Data, nie jest dostępny, gdy używamy MVVM. Zamiast tego napisałem funkcję `fetchLocations` tutaj, która tworzy deskryptor zapytania (`fetch descriptor`).

> This is how you fetch data from Swift data manually now. And then I will just say modelContext.fetch that fetch descriptor. And this is also a bit of an ugly line of code here with all of these optionals and optional chains and nil-coalescing operators to you on the right-hand side. This can get pretty dumb. I just wanted to show you how this works in general. And also just quickly letting you know that in the fetch descriptor, you have to specify the generic type either through these generic clauses here, or you could, of course, just tell Xcode explicitly which type this should return in the end. And then you don't need to add this part right here. But as with the query property wrapper, you could also specify a predicate. And in this case, I'm showing you all of the locations except for my secret location, which doesn't even exist. I just wanted to show you how the predicate works. And then I'm also sorting by the location's name. So this is just our fetchLocations function. But as you might have noticed, this is not a live updating database subscription like the query would be. Instead, you would have to implement that through notifications yourself. I have not done that for this video, but I will talk to you about how I would implement things like this in a bit. So when my list appears, I'm just assigning the model context and then saying viewModel.fetchLocations. And in the list, I'm just showing viewModel.locations, really nothing fancy here whatsoever. And then in the toolbar over here, I also have an add button that just calls viewModel.createLocation. And that function is also very simple. 

To jest sposób na ręczne pobieranie danych z Swift Data. Następnie używam `modelContext.fetch` z tym deskryptorem zapytania. Jest to trochę brzydkie wiersze kodu ze wszystkimi tymi opcjonalnymi wartościami, łańcuchami opcji i operatorami nil-coalescing po prawej stronie. To może być dość zagmatwane. Chciałem tylko pokazać ci, jak ogólnie to działa. Chciałem ci również szybko przekazać, że w deskryptorze zapytania musisz określić typ generyczny albo poprzez te klauzule generyczne tutaj, albo oczywiście po prostu podać Xcode'owi jawnie, jaki typ powinien zwrócić na końcu. Wówczas nie musisz dodawać tej części tutaj. Podobnie jak w przypadku property wrappera `@addQuery`, możesz także określić predykat. W tym przypadku pokazuję ci wszystkie lokalizacje oprócz mojej tajnej lokalizacji, która nawet nie istnieje. Chciałem tylko pokazać ci, jak działa predykat. A następnie sortuję lokalizacje według ich nazwy. To jest nasza funkcja `fetchLocations`.

Ale jak mogłeś zauważyć, to nie jest subskrypcja bazy danych z automatycznym aktualizowaniem na żywo, tak jak w przypadku property wrappera `@addQuery`. Zamiast tego musiałbyś samodzielnie zaimplementować to za pomocą powiadomień. Nie zrobiłem tego w tym wideo, ale za chwilę opowiem ci, jak bym to zrobił. Kiedy mój widok listy pojawia się, po prostu przypisuję `modelContext` i potem mówię `viewModel.fetchLocations`. W liście po prostu pokazuję `viewModel.locations`, naprawdę nie ma tutaj nic skomplikowanego wcale. A potem w pasku narzędzi mam także przycisk dodawania, który po prostu wywołuje `viewModel.createLocation`. I ta funkcja jest także bardzo prosta.

> Create a new location, insert it into the model context. Then you can optionally call save or just rely on the autosaveIsEnabled flag of your model context or your model container. So in most cases, you can get rid of this line here. You probably don't need that. But in case you want to manually save, it's always a possibility. And then you have to decide how you want to approach this stuff, since just inserting it into the context will not actually show you new data in the list, since it's not automatically updating through the query property wrapper. So instead, you will have to either manually reload using this fetchLocations function, or you can manually insert the location into your locations array. But, and I simplified this here once again, you will then have to also sort again, since we did have a sort descriptor by name. And now it's not sorted anymore. So this is something you will have to think about yourself as well. 

Tworzysz nową lokalizację, wprowadzasz ją do kontekstu modelu. Następnie opcjonalnie możesz wywołać `save` lub po prostu polegać na fladze `autosaveIsEnabled` twojego kontekstu modelu lub twojego kontenera modelu. W większości przypadków możesz pozbyć się tego wiersza. Prawdopodobnie nie potrzebujesz go. Ale jeśli chcesz ręcznie zapisać, zawsze masz taką możliwość. Musisz więc zdecydować, jak chcesz podejść do tego, ponieważ tylko wprowadzenie go do kontekstu nie spowoduje automatycznego odświeżania danych na liście, ponieważ nie jest to automatyczne odświeżanie za pomocą property wrappera `@addQuery`. Zamiast tego będziesz musiał ręcznie załadować dane używając funkcji `fetchLocations` lub ręcznie wprowadzić lokalizację do swojej tablicy lokalizacji. Ale, i tutaj także uproszczam to, będziesz musiał także ponownie posortować, ponieważ mieliśmy deskryptor sortowania według nazwy. Teraz nie jest już posortowane. To jest coś, o czym będziesz musiał samodzielnie pomyśleć.

> Or, of course, the third option is to listen to notification center notifications for when the underlying data changes and then running the fetch descriptor again automatically. I have never implemented that myself, but I know that folks are doing that. So it is probably also possible for Swift data. So all in all, I would say it is absolutely possible to use MVVM with Swift data together in an app. I personally will not use this. I personally will just rely on the query property wrapper. It's just a too nice experience for me to not use it. And then all of the other stuff is so little code. I mean, honestly, it's just two lines of code to create and insert a new object into Swift data. Do I really need to create its own function in a view model or just have a second line of code here? Totally depends on your use case if you want to go with MVVM or with view only. I will personally not do MVVM, but it is completely possible with Swift data. Thanks. you you

Oczywiście, trzecią opcją jest nasłuchiwanie powiadomień z Notification Center, kiedy zmieniają się podstawowe dane, a następnie automatyczne uruchamianie deskryptora zapytania ponownie. Osobiście nigdy tego nie implementowałem, ale wiem, że ludzie to robią. Jest to prawdopodobnie także możliwe dla Swift Data.

Podsumowując, powiedziałbym, że całkowicie możliwe jest używanie MVVM z Swift Data w jednej aplikacji. Osobiście nie będę tego używać. Zamierzam polegać tylko na property wrappera `@addQuery`. To dla mnie zbyt dobre doświadczenie, aby z niego nie korzystać. I wszystko inne to tak mało kodu. Chodzi mi przecież o to, że naprawdę są tylko dwie linie kodu, aby stworzyć i wstawić nowy obiekt do Swift Data. Czy naprawdę muszę tworzyć oddzielną funkcję w widoku modelu, czy wystarczy tylko druga linia kodu tutaj? To całkowicie zależy od twojego przypadku użycia, czy chcesz iść z MVVM czy z widokiem tylko. Osobiście nie będę stosować MVVM, ale z Swift Data jest to całkowicie możliwe. Dzięki. Do zobaczenia!