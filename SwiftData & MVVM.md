SwiftData & MVVM 

So let's start by looking at our model at the very top of this file. So it is annotated with add model, which makes it usable with Swift data. It's just a very simple location class with a single attribute being a name string. So absolutely nothing fancy here inside of the model. Then I have created a view model, which is also just a class, but annotated it with the add observable macro, which is part of the observation framework, in case you didn't know. That is also implicitly imported through Swift data, so you don't need to explicitly import observation. If you have already imported Swift data, you can get rid of that. Now, here's one of the first issues for W3C, is things that need to get figured out down the road, which is similar to how it had to be handled in Core Data. We once again have a model context. We also had a context in Core Data. Now in Swift data, we have the model context. There are probably a bunch of different ways of giving your view model access to that context. I could imagine having a shared instance of that context and just accessing that, similar to how you would have your persistence controller.shared instance in Core Data. You could use a dependency injection approach, using, for example, a framework that has a property wrapper to get your dependencies from, which could be a great idea, in my opinion. I have gone with the simplest approach in this example, but you're free to try out whatever works for you. So I just have an optional model context here, which is nil. When creating the view model, I'm just setting this to be the context that we are actually using. And I'm doing that inside of my view, so I'm grabbing the context from the environment. I have a state of my view model. This is how you're using view models now. No more state objects. You can use state or bindable, but state should be fine in this case, since we're not binding to any values in the view model. And then in the onAppear of this list over here, I'm just telling my view model to use the model context from the SwiftUI environment. So this is just the simplest setup, but we will have to deal with options here. Dependency injection is probably a better approach. Next, the view model has an array of locations. You might notice here that it is not annotated with addQuery, because addQuery only works in views. So this magical property wrapper here that I so much appreciate and already appreciate it as a fetchRequestPropertyWrapper at core data is not available to us when we're using MVVM. Instead, I wrote a fetchLocations function here, which creates a fetch descriptor. This is how you fetch data from Swift data manually now. And then I will just say modelContext.fetch that fetch descriptor. And this is also a bit of an ugly line of code here with all of these optionals and optional chains and nil-coalescing operators to you on the right-hand side. This can get pretty dumb. I just wanted to show you how this works in general. And also just quickly letting you know that in the fetch descriptor, you have to specify the generic type either through these generic clauses here, or you could, of course, just tell Xcode explicitly which type this should return in the end. And then you don't need to add this part right here. But as with the query property wrapper, you could also specify a predicate. And in this case, I'm showing you all of the locations except for my secret location, which doesn't even exist. I just wanted to show you how the predicate works. And then I'm also sorting by the location's name. So this is just our fetchLocations function. But as you might have noticed, this is not a live updating database subscription like the query would be. Instead, you would have to implement that through notifications yourself. I have not done that for this video, but I will talk to you about how I would implement things like this in a bit. So when my list appears, I'm just assigning the model context and then saying viewModel.fetchLocations. And in the list, I'm just showing viewModel.locations, really nothing fancy here whatsoever. And then in the toolbar over here, I also have an add button that just calls viewModel.createLocation. And that function is also very simple. Create a new location, insert it into the model context. Then you can optionally call save or just rely on the autosaveIsEnabled flag of your model context or your model container. So in most cases, you can get rid of this line here. You probably don't need that. But in case you want to manually save, it's always a possibility. And then you have to decide how you want to approach this stuff, since just inserting it into the context will not actually show you new data in the list, since it's not automatically updating through the query property wrapper. So instead, you will have to either manually reload using this fetchLocations function, or you can manually insert the location into your locations array. But, and I simplified this here once again, you will then have to also sort again, since we did have a sort descriptor by name. And now it's not sorted anymore. So this is something you will have to think about yourself as well. Or, of course, the third option is to listen to notification center notifications for when the underlying data changes and then running the fetch descriptor again automatically. I have never implemented that myself, but I know that folks are doing that. So it is probably also possible for Swift data. So all in all, I would say it is absolutely possible to use MVVM with Swift data together in an app. I personally will not use this. I personally will just rely on the query property wrapper. It's just a too nice experience for me to not use it. And then all of the other stuff is so little code. I mean, honestly, it's just two lines of code to create and insert a new object into Swift data. Do I really need to create its own function in a view model or just have a second line of code here? Totally depends on your use case if you want to go with MVVM or with view only. I will personally not do MVVM, but it is completely possible with Swift data. Thanks. you you