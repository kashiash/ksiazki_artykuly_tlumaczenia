#Karen Partner zależność Observable

Both in terms of complexity and your app's performance, with iOS 17, this is updated with the new observation. And there's two different problems this is solving. The first one I was just trying to demonstrate with this little diagram here. If you look at the existing property wrappers and the data flow, this is quite a lot of different elements involved with all these state objects, the observable objects, the environment, at state and at binding. This is now much simpler with the observation. As you see, there is a lot less on that side. We only need to consider the at state and bindable property wrappers and the environment. And one of the major parts is the new at observable macro that helps us to get the data flow properly. You can see observation as an alternative to the existing data flow. If you're targeting iOS 17, this should make it easier for you to write your model files. Additionally, the other topic that observation helps us with is the app's performance, especially if your app gets more complex and you have a lot of different views and state that you're sharing. You get problems where your views update too often and this is starting to be noticeable by the user by some hangs or lagging. And observation makes this a lot easier to properly update views only when they actually need to be redrawn, when their state what they're showing needs an update. And in order to demonstrate you this part of the performance improvements and also to show you how to transition from one to the other, I was looking for good examples, but it's a very difficult topic to get into. So in the end, we are going to use the demo project from the DevDevDC 2023 where they use the observation. I did modify this so I can demo this because I really want you to see the difference. I took this demo project and I wrote it backwards to the observable object and the previous state with all these property wrappers. I'm going to show you now how the performance of this is. We're transitioning to the new observation. Show you all the what you replace with what. And then in the end, I'm going to show you that it indeed improves the performance. And we can actually also tell you a little bit of how you can actually see when things are redrawn too often. This is not the easiest because SwiftUI, it's meant to automatically magically happen in the perfect way. So every time something changes, it really shows the new changes, but only when something changes so it doesn't do more work. Let's have a look at the demo project. This is an app where I have a list of books in a library. And in the library view, I used here a navigation view. This is the old school style because some parts of the demo for this performance, I can't just use a navigation stack. I need to see more views so we see what updates which parts of the app. And I'm running this here on the iPad in landscape mode. So I have here the whole app with the sidebar. This is a list of 101 books. And on the right, you have the book details. If I change this, you see it's book title four, five. Down here, this opens an editor and I can change the book title. So this is book title five, which is the green one here. And now I can change this to special. So every time my book title changes, the model, the views that use this data need to also update. This includes this list where I use this book data for this cell. And as you saw, it updates and now has the correct new title, which is book special. Additionally, I added here background color. This is a trick from Peter Steinberg where he generated a random color and I used this to attach it to each of this library item view. So here I use an icon that I pass the book title and the author name. This is the data this view shows. And whenever anything of these is changing, I want to have an update to redraw my view. And in this case, I changed the title, which is used here. So every time the title changes, it needs to redraw to show the new title. To this view, I added this random color, which means that every time my book title changes, this cell needs to be redrawn because my title changes, this text needs to be updating. With the help of this color background, we can now really see if it redraws what is updating. It's only the cell that I'm changing my data. The other ones stay the same. This is how it's supposed to be. Now, the other property that this book has that I actually didn't use here in this view is a boolean value is available. Now when I have here in this detail view, the toggle to change this boolean value to just toggle this. So now I can say check out and the text in the detail here changes. What also happens is that my cell background changes. As you see here, if I tap, it changes. So this one property changes, which means that this cell now redraws. Although the property I didn't use it in the cell. It redraws it, although it's not necessary because none of the text that I use changes. This is clearly a performance issue because it's more work than it has to do. As you see, using this background colors is quite nice to see that we have here a small, a small but a performance issue. And later with the help of the new observation, you will see that we get rid of this. The other thing I also added is here this print statements. Every time something changes or now I need to make this smaller. Every time I change one of my properties and this view is evaluated or redrawn, we see this. So if I now press here, check out, you see something in the library view changed or actually it's the library. So this is this view model here. This is changed, which means then it's checking what it has to update in here. And then it says, because of this print statement, I have self changes. So my whole view changes. So this was recreated. Which we visually see because of this background color. This is just a small trick to see if something updated. OK, now that we have this project, I want to actually modify this to the new observation so we can optimize the performance of our app and also make it more simple. Now when I go back to this overview, the new observation style has two parts. So previously you would have view models, models and views or classes and struct differences. And now we only have the view part with two property reference to main property reference that we care about is at state and at bindable. From our model side, all of our models are classes and we can easily get these data flow going by adding the at observable macro. Let's start by looking at our model file. In my project, I created another branch. You can find this project in the link in the description on GitHub. So I created here a separate observation branch that I'm going to switch to. This makes it easier for me to go back and forth between these two versions. Now another thing that I'm going to add for this is here the navigation title. I'm going to change to observation. That makes it easier for the simulator to see what I'm actually using. Let's now have a look at a model file that I have. There's already one model folder and we have here author. This is a struct data. You have a struct book. This is a data and we have library. This is different because it conforms to a single object. In the terms of MVVM, this would be a view model that owns an array of data too for my books. We're going to work on all of these free files and instead of handling them, these free in a different way of your model class and structs, they're going to be much more uniform. Let's start with the author. I need to import for all of these, the observation module. Then we change to a class and I use the new observable macro. This macro adds a lot of functionality like the observation protocol. Now because this is a class, it needs actually an initializer. I'm simply here changing this. In a similar fashion, we're going to work on the next file, which is the book. Again, I need the observation module. It cannot be a struct anymore. Everything is a class. You don't need to think about this anymore. I need to have here the add observable macro. This one complains because it doesn't have a proper initializer. Also, Xcode helps you with creating these initializers. Next we're going to go in the library. So I again need to import here the observation. It is already a class conforming to observable object. I don't use this anymore because we're using the new observation and again the macro. This adds some functionality and one of them is already complaining is that you shouldn't use here this add published. All the stored property that are in this observed models, like here my books, they are tracked and SwiftUI knows when they're updated and will correctly redraw the views for this. If you choose to not do this, there is an observation ignored macro. In this case, when my title changes, we won't see this in the views. Maybe I'm going to do this in a minute after we actually converted everything. So let's just see how much it's going to complain. It basically complains a lot about every time I used here state objects or environment objects because now we don't conform to observable object anymore. This is a good way of remembering what to change. If you have a state object, it's simply to remove the object part. So it's only state. We only have two property to use the, or actually three, but the two main ones is at state declaring here state model library or a bindable. Then it's complaining here environment object and we're going to pass this not as an environment object. We're going to use the environment system that is provided. For example, here in one of my views, I would access something from the environment, like the horizontal size class. Sim, we are using now the same system as this for own types. I go in the library where we declare this. So there's two parts that we need to define. Let's just start with the environment key. So this is a private struct library key. So I'm using my types name and I'm adding here key conforming to environment key. This has one requirement, which is, no, it doesn't do it correctly. The one requirement is to have a static var named default value with the value that we are using. This is my library and to give all value, we're just creating a new dummy library. This is the fallback value. In case we didn't pass anything. Then in order to get the, you saw me using the property wrapper at environment and then just using the path in order to have this access there and to properly pass it in the environment, we need to write an extension to the environment values with a var library. This is the value we see now in the property wrapper of type library or type that you want to pass here. And I need to write a get and a set so it knows how to get this and how to set this. So it gets it by identifying it here with this environment key that we just wrote. So this is self. So in all of the list of my environment values, look for the one that has the type of library key. So this is how we say this. If you want to set this, we are going to again use this access it from our list of environment keys and we set this with a new value. Okay. Now this is ready and we can use it in the views and similar to you, this environment object where I pass it in the environment, we also need to, we need to actually generate one of these values and you can use the environment with key path. This is also the way you override things. For example, you could override the environment value for color schema with a certain value. This was not the point. I want to use the library and I'm going to use the value that we generated here. Okay. This is the first part. I'm passing in the environment and the environment has a value to do this. Now going to the library view where it complained that we can't do this because it's not observable object. Yes, we don't want to use this style. It's the same style as I used just now before. So this is the library and then it's the private var. I don't need to specify the type here because it knows from the environment, from our declaration. When I do this, I also need to change it in my previews. So same style again, as I saw in the main app file, identifying this here, we have the library environment key and generating a new library instance. So you could also pass in here a special one for your previews. Let me just finish and replace all the environment objects before I deal with the other problems. So I'm just using the search in my book view. I have the same and just use this. So no more environment object, just the environment with the library. And in the preview, we also do the same by using the environment, by setting the library value here. Okay. Now I replaced the environment and we go back to the library view. We have now another problem. I have your list of my library items with a navigation link and the book view, the detail view. I did change some of the properties for each of these books, like changing the title or if it's available. That's why I had to pass in here binding. Now as you see, the binding doesn't work with this model observation and it's very easy. I don't actually need to use passing your binding. I just pass in the values like normally. So I don't need to use lists with bindings. Just pass it. Okay. This is now moving the problem further to my book view where I have here binding for this book because I am changing stuff like toggling this available property. Binding is with structs and the data we had before. So I have to remove this. This is now solving my problem in the view before. And also now here in this preview, change this just passing the value model directly. I now move my problem further to my book edit view. Again I don't pass in here with the dollar sign the bindings. Now let's go to the book edit view. Again I don't use binding, which means I also don't do this in the preview. But here I have a text field where I need to give a binding to a string value. This is, I can't work around this. I need to address this. If you have a binding in the view inside here where it really requires this, you can add a another property wrapper, which is the new bindable. And now I have here a binding available that I can pass to my text field and to my toggle. You can just add this here. I don't need to handle this in one level higher like I had before here with this binding. Just pass it from the parent to this child view subview here directly. And then I only need to add here this bindable. So this is definitely one step less of worrying about all my preview. So that's very convenient. Let me just check what other problems. I'm building, we are launching and it's working. So I can still here open this. And open my edit view. And now this is book title one, so the pink one. If I change the title, you see the color changes and the view. Maybe should find something. And the text also updates. This is as I wanted to, because it is using this property. Now if I toggle this book is available, this property is available. It was not used in this list items. So we shouldn't, we don't want to redraw, so the color should stay the same. And you see it does. What changes is here, this other text. So this is for something that I added in the toolbar, which counts how many books are available. So now this is available. If I check it out, it's not available. And the count changes from 100 to, from 101 to 100. So this view updates correctly because it uses this property. Whereas this cell doesn't use this property, so it doesn't update. The way this observation works is on a property level. So it's not like before, because I had struct, it was always updating when anything inside was updating. Actually, it wasn't my book view. Now let's just do the last test with this observation ignored. So I said, I don't want to have updates if I now try to type here something. The text field updates because it has the new values, but the views that use this properties don't update anymore. So you see here my book title three stayed the same. In this case, I definitely don't want this, but it is a possibility to further optimize this. Okay. I'm reverting to before. As you saw, I very easily get this proper updating of really only the views that are necessary. This is the part where observation helps us improve the performance of our apps. And I also showed you how to change the structure of your apps, how to implement this in code. And it makes it a lot easier because you don't need to think like in my case here, I have a book, what do I do? Just make it class, everything is class and is model related. Everything becomes at observable. Same for the library, which is different. And the nice thing is if you store other observables in one of your observables, they also get this automatic updating. Previously with the observable objects, if you would have contained something in there and one of this properties changes, then the updating wouldn't have worked. So you wouldn't, nesting view models before would not have the same effect with the updating. Although that's one of the tricks to have less updating. Usually with the previous one, it feels always a little bit like workaround, but now with at observable, we don't need to think about this. So everything is a class, everything is an observable. From the values, passing values with the environment is a little bit more complicated because you just need to follow this template, adding some code. When you declare a model in a view and the view is the owner, then you add a at state. When you just pass it as a value and like here in my book view, then you don't need to add any property wrappers. If you do this, you can still change it, some of the properties, like with a button, the binding that we had previously, like in my book edit view, here I need to add a bindable property wrapper, which makes it, when you pass this down from the parent, like here for my book view to my book edit view, I don't need to tell it that I use your binding or anything. So from this view, it doesn't really care what goes down. So I don't need to worry about this binding that makes my previous easier. When I work with bindings in this, that makes it easier. So in this term, it's much nicer, actually. Overall, if you have a project that you're only building for iOS 17 and only in Swift UI, then this is probably the way to go. Just to help you in terms of performance and development. They also use this whole system for Swift data, where you also get the advantages of this passing this data and getting the performance improvements in contrast to like core data, which uses the older system. From an architecture point of view, you really only have views and model files. You don't distinguish between view models and models. It's everything just a model. Everything is just an observable. Whereas before it was more distinction between view models, so class types, where you handle data and models, and then the views. It's one of the reasons why it's no simpler, because you just treat everything the same that is model related. You don't need to think of which property wrappers to use to get the right updating going. Now, as a bonus, I'm going to also show you how you can write your code to get the same behavior as we had now of not updating the views unnecessarily, or to pay attention to and what is still a problem or how you can really mess it up. Because it's a lot of cases is how you write it. Swift UI sometimes feel, this is an area where Swift UI very much feels like you're reversing this engineer stuff. You have to really think in a way that go with the system behavior. I did create another branch from the observable object variant of this project. So you see here again, I have this environment object. And I have here the list of all my books. And I show as a label in this navigation link, the library item view where I passed the whole book. So the whole struct instance. If I check this out, this struct changes, which passes a new book instance because the struct is value types. So every time you change a property in a struct, the whole struct changes. So this library item view has a new book, which tells it, oh, I need to redraw myself because my data changed because I passed too much data here. So it thinks it needs all of this data to update. Instead of the whole book, I'm only passing now the values that it actually needs. So I go in my library item view, which is the cell. So here I only have the book's title and the author name. So this is the two properties that I'm going to change. This is the book title string and the book author name string. So I removed the book, the whole book, and we are only using this smaller data. This is book author name. This means my arguments here changes in the preview title and author. The preview is now working and I can go to library view because we need to also pass this now here. So this is the book's title and the book's author's name. So now when I open one of these links and I press here available for checkout, this one property changes that now I don't pass this anymore. And you see the cell color doesn't change. The rest is updating here, like here, books available. This is updating, but not my cells. Can also try this with the other ones. When I try to change the name, this is now still working because this is the value that I'm still passing. As you see, in order to make it work with the proper updating, I only really should pass the values that it needs. This is one trick. The big problem with this strategy is, or the opposite way of messing it up is if you use a lot of environment objects because they are passed everywhere. For example, here in my book view, I use this environment object because I have here a delete button where I want to delete this. I need to use my library environment. So this view now accesses this environment object. So it relies on it and always checks if something in there goes on. In this case, it is okay because I'm not using any of the values in there. So it doesn't update. So it will not actually redraw this, but you will get an evaluation. So the system will check if this view is updated or not. This is already a little bit of a concern. Where I used a lot of these environments or one thing that I use with environment objects is the state of my whole application, the navigation state of everything or the app state, which I put in the environment so I can change all these properties from anywhere. Like from one part of the app, I can say, open this link or open settings or show a different one. So in this case, because you're using this quite a lot in everywhere and it also has properties that are used everywhere, it's very much prone to cause performance issues. So this is the one place where I really would replace this. The other thing you should definitely not do is, for example, in the initializers, don't, some people would say, I need to calculate something or fetch something. Don't do this. In the initializers, because every time I redraw something here, this would happen. That's why you're supposed to use the onAppear because this is only called when this view appears and not when it redraws this view. That's one of the tricks to definitely look out for. And then the other thing that you can also mess up with, I try to mess things up a little bit, is to make it really hard for the system to understand when things change. So here, this icon name, I didn't talk about this before. So I just added one icon index number to each of my books and then it takes, goes into this array and takes the index out of this. Now we are changing this and saying, oh yeah, you just use one of these random elements, anything of these, which means that when this view, this item here is created, then we are calculating from this random array, one of these icons. So before I only did this when it was initialized. Now when I press you check out and you look at the icons and the colors, then everything changes. That's because the system is, okay, apparently I need to recalculate this every time. What it does, it's comparing data of the, it takes a snapshot of the old data and compares it to the new data and when this changes, it recreates it. In my case, it's like, okay, let's see if something here changes. My library changed. Okay, let's compare the old icon. It still has this. And let's see what the new one is. The new one is recalculate every, I use a new random one. So it's okay. Apparently I have new data now. So I need to redraw everything. So definitely don't calculate something that you pass in initializers. They also said for something like computed properties, it's also might also cause this if it doesn't understand if something updated or not. Let's go back because this implementation is quite messy. Then another thing that was interesting, which is also doesn't manage to do is if I use a text field in a list, this is with a binding, text binding of my book's title. For my little demo, I take out the link and we're just putting a text field. Okay, I could also remove the navigation view and I need to again add here a background color dot random. Every time I focus one of the text field is also evaluating and changing the colors. When I type, it doesn't realize it's only one text field that changed. And as you see, everything changes. This is definitely not supposed to be like this. And it also does the same weird behavior with the new observation feature. So this is definitely something that I don't like. Now you could say on iOS, it's probably not a thing and then you might not have to so often. So let's look on MacOS. Okay, it does not update this first, but as soon as I start typing, I still have the same issue. It does here too much work from the print statement tells me that library changed and so it changes everything. I don't have here the print statement of each of the cells anymore because I'd only use the text field, but it changes everything. Because apparently it doesn't understand what's going on. I'm just going to go back to my initial version that was working fine. This is the thing with SwiftUI. You have this magically updating happening for you. And in 99% of the cases, it's probably doing the job correctly or pretty much good enough. But the 1% can really make a difference in the performance of your app. It redraws some views so much that you can feel as the user lagging in your app is like stuttering, scroll performance issues, something like this. And then it's really difficult to manage because you need to modify it. You need to think and modify your project in a way that reverse engineering the way SwiftUI updates this so it doesn't do it too often. That can be quite annoying if you are struggling with this. UIKit is much better for this because you have to do everything so you can decide on the whole updating mechanism. As a summary, you saw that we have this alternative way of managing our data flow. It's not replacing, you don't need to use the new observation. It's just another way that helps you write your project in SwiftUI. If you're lucky enough to write a project that supports iOS 17 and higher, then definitely have a look at it. It makes it easier and simpler because you don't need to handle all of this different property wrappers, managing your data. So it makes it more uniform to work with and the views and the model files. It also helps you with the performance to only update when it's really necessary. If you work with Swift data, definitely have a look and learn about it because Swift data is always conforming to observation. So you need to deal with this. The whole observation works more with view model architecture because we really only have this two different files types, views and model files. Whereas previously with the old property wrappers and the observer object, we have three different types of view model, model and views or the class and the struct difference there. The new style still uses combine under the hood. We don't really know, but the whole updating mechanism in SwiftUI works so far in combine. So I'm guessing they still use it. What you don't get with the new ones that one of the use cases where the old system is still valid because I have here this at publish properties, I can really create my own data stream to say, oh, update this now, evaluate this now. For example, if you have a form validation, like a user authentication where you have to put in the username, password and repeat the password, and then you need to check if the passwords are the same, if they're long enough, if the email is correct and you always have to update one or the other, and you just want to evaluate and combine these three inputs in an efficient way, then combine is still more, the publish properties is still better. They have something similar where you can run some code and when one of these properties changes, you can also add a did set or a will set. But so far with the beta, I didn't really get this working properly. Maybe when they release it, it is improved. Overall, I think the fact that they are now putting so much effort into improving the performance of SwiftUI is a good sign because then it really means that SwiftUI is getting more stable and reliable. They're working on more fine-tuned features, not just bugs, like really improving and bringing it forward. So it's actually a good addition to the whole SwiftUI ecosystem. I will also make some videos about Swift data where I will use the whole new system for observation. So don't forget to subscribe and use the bell notification if you don't want to miss that one. In the meantime, if you want to learn more about the data flow for the existing property wrappers, I will also have some videos about these ones. Thank you for watching. Please like this video, that would help me a lot. Until next time, happy coding. Bye. Bye.